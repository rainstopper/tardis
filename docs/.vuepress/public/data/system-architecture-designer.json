{
  "nodes": [
    { "name": "系统架构", "category": "架构", "description": "系统架构（System Architecture）是系统的一种整体的高层次的结构表示，是系统的骨架和根基，支撑和链接各个部分，包括组件、连接件、约束规范以及指导这些内容设计与演化的原理，它是刻画系统整体抽象的一种手段。系统架构设计的目的是对需要开发的系统进行一系列相关的抽象，用于指导系统各个方面的设计与实现，架构设计在系统开发过程中起着关键性作用，架构设计的优劣决定了系统的健壮性和生命周期的长短。我们通常把架构设计作为系统开发过程中需求分析阶段后的一个关键步骤，也是系统设计前的不可或缺工作要点之一，架构设计的作用主要包括以下几点：\n1、解决相对复杂的需求分析问题；\n2、解决非功能属性在系统占据重要位置的设计问题；\n3、解决生命周期长、扩展性需求高的系统整体结构问题；\n4、解决系统基于组件需要的集成问题；\n5、解决业务流程再造难的问题。\n系统架构设计是成熟系统开发过程中的一个重要环节，它不仅是连接用户需求和系统进一步设计与实现的桥梁，也是系统早期阶段质量保证的关键步骤。" },
    { "name": "IEEE 1741-2000", "category": "标准", "description": "IEEE 1741-2000：“IEEE's Recommand Practice for Architecture Description of Software-Intensive Systems”（软件密集型系统架构描述的推荐实践）" },
    { "name": "系统架构设计师", "category": "架构", "description": "系统架构设计师（System Architecture Designer）是担任系统架构设计的核心角色，他不仅是连接用户需求和系统进一步设计与实现的桥梁，也是系统开发早期阶段质量保证的关键角色。" },
    { "name": "软件架构", "category": "架构", "description": "软件架构（也可成为体系结构）是用来刻画软件系统整体抽象结构的一种手段，软件架构设计也是软件系统开发过程中的一个重要环节。随着研究的深入和应用的推广，软件架构逐渐成为软件工程学科的重要分支方向，在基础理论和技术方向等各工程实践领域形成了自己的独特理念和完整体系。" },
    { "name": "模块化", "category": "架构", "description": "模块化开发方法是指把一个待开发的软件分解成若干个小的而且简单的部分，采用对复杂事物分而治之的经典原则。模块化开发方法涉及的主要问题是模块设计的规则，即系统如何分解成模块。而每一模块都可独立开发与测试，最后再组装成一个完整软件。对一个规约进行分解，以得到模块系统结构的方法有数据结构设计方法、功能分解法、数据流设计和面向对象的设计等。将系统分解成模块时，应遵循以下原则：\n1、最高模块内聚。也就是在一个模块内部的元素最大限度地关联，只实现一种功能的模块是高内聚的，具有三种以上功能的模块是高内聚的。\n2、最低耦合。也就是不同模块之间的关系尽可能弱，以利于软件的升级和扩展。\n3、模块大小适度。颗粒过大会造成模块内部维护困难，而颗粒过小又会导致模块间的耦合增加。\n4、模块调用链的深度（嵌套层次）不可过多。\n5、接口简单、精炼（扇入扇出数不宜太大），具有信息隐蔽能力。\n6、尽可能地复用已有模块。" },
    { "name": "服务导向架构", "category": "架构", "description": "面向对象服务架构（Service-Oriented Architecture，SOA）基于模块化思想提出，提供一组基于标准的方法和技术，通过有效整合和重用现有的应用系统和各种资源实现服务组件化，并基于服务组件实现各种新业务应用的快速组装，帮助企业更好地应对业务的灵活性要求。这样，通过有效平衡业务的灵活性和IT的复杂度，为开发者提供了新的视角，有效拉近了IT和业务的距离。" },
    { "name": "管理信息系统", "description": "管理信息系统（Management Information System，MIS）。传统MIS系统软件架构：\n<img src=\"https://regular-files.oss-cn-hangzhou.aliyuncs.com/mis.jpg\" />" },
    { "name": "组件化", "category": "架构", "description": "IEEE 1741-2000标准发布阶段最重要的成果之一是软件组件化技术，通过沿用20世纪的工业组件概念，提升了软件重用能力和质量。\n通常，组件具有可组装性和可插拔性。每个组件的运行仅依赖于平台或者容器，组件与组件之间不存在直接的耦合关系。同时，组件与组件之间又并非绝对独立。组件经过组装后可以与其他组件进行业务上的交互。" },
    { "name": "应用集成", "description": "应用集成是将一些基于不同平台或不同方案的应用软件有机地集成到一个无缝的、并列的、易于访问的单一系统中，以建立一个统一的综合应用。" },
    { "name": "架构描述与表示", "category": "架构" },
    { "name": "架构描述语言", "category": "架构", "description": "架构描述语言（Architecture Description Language，ADL）" },
    { "name": "C2SADL", "category": "架构", "description": "基于组件和消息的软件架构描述语言" },
    { "name": "Wright", "category": "架构", "description": "分布、并发类型的架构描述语言" },
    { "name": "ACME", "category": "架构", "description": "架构互换语言" },
    { "name": "UniCon", "category": "架构", "description": "基于组件和连接的架构描述语言" },
    { "name": "Rapide", "category": "架构", "description": "基于事件的架构描述语言" },
    { "name": "Darwin", "category": "架构" },
    { "name": "MetaH", "category": "架构" },
    { "name": "Aesop", "category": "架构" },
    { "name": "Weaves", "category": "架构" },
    { "name": "SADL", "category": "架构" },
    { "name": "xADL", "category": "架构" },
    { "name": "架构分析", "category": "架构", "description": "架构分析的内容可为结构分析、功能分析和非功能分析。分析的目的是系统被实际构造之前预测其质量属性" },
    { "name": "架构分析方法", "category": "架构" },
    { "name": "SAAM", "category": "架构", "description": "软件架构分析方法" },
    { "name": "ATAM", "category": "架构", "description": "架构权衡分析法" },
    { "name": "CBAM", "category": "架构", "description": "成本效益分析法" },
    { "name": "SBAR", "category": "架构", "description": "基于场景的架构再工程" },
    { "name": "ALPSM", "category": "架构", "description": "架构层次的软件可维护性预测" },
    { "name": "SAEM", "category": "架构", "description": "软件架构评估模型" },
    { "name": "架构设计", "category": "架构", "description": "架构设计是指生成一个满足用户需求的软件架构过程。" },
    { "name": "架构设计方法", "category": "架构" },
    { "name": "工作驱动", "category": "架构", "description": "从工作描述中提取架构描述的工作驱动（artifact-driven）方法" },
    { "name": "用例驱动", "category": "架构", "description": "从用例导出架构抽象的用例驱动（use-case-driven）方法" },
    { "name": "模式驱动", "category": "架构", "description": "从模式导出架构抽象的模式驱动（pattern-driven）方法" },
    { "name": "域驱动", "category": "架构", "description": "从领域模型导出架构抽象的域驱动（domain-driven）方法" },
    { "name": "属性驱动设计", "category": "架构", "description": "从设计过程中获得架构质量属性需求的属性驱动设计（attribute-driven design）方法" },
    { "name": "架构测试", "category": "架构", "description": "架构测试着重于仿真系统模型、解决架构层的主要问题。" },
    { "name": "架构测试策略", "category": "架构" },
    { "name": "单元测试", "category": "架构" },
    { "name": "子系统测试", "category": "架构" },
    { "name": "集成测试", "category": "架构" },
    { "name": "验收测试", "category": "架构" },
    { "name": "架构测试方法", "category": "架构" },
    { "name": "架构测试覆盖方法", "category": "架构" },
    { "name": "组件设计正确性验证方法", "category": "架构" },
    { "name": "基于CHAM的架构动态语义验证方法", "category": "架构" },
    { "name": "架构发现", "category": "架构", "description": "软件架构发现解决如何从已经存在的系统中提取软件架构的问题，属于逆向工程。Waters等人提出了一种迭代式架构发现过程。" },
    { "name": "迭代架构发现过程", "category": "架构" },
    { "name": "架构演化", "category": "架构", "description": "软件架构演化即由于系统需求、技术、环境和分布等因素的变化而最终导致软件架构的变动。软件系统在运行时刻的架构变化成为架构动态性，而将架构的静态修改称为架构扩展。架构扩展和动态性都是架构适应性和演化的研究范畴。" },
    { "name": "架构适应性", "category": "架构", "description": "软件系统在运行时刻的架构变化成为架构动态性。" },
    { "name": "架构扩展", "category": "架构", "description": "架构的静态修改称为架构扩展。" },
    { "name": "架构复用", "category": "架构", "description": "软件架构复用属于设计重用，比代码重用更抽象。" },
    { "name": "架构模式", "category": "架构", "description": "架构模式是架构复用的一种成果。" },
    { "name": "开发模型", "category": "架构", "description": "软件开发模型是跨越整个软件生存周期的系统开发、运行和维护所实施的全部工作和任务的结构框架，给出了软件开发活动各个阶段之间的关系。" },
    { "name": "瀑布模型", "category": "架构", "description": "以软件需求完全确认为前提的瀑布模型。" },
    { "name": "渐进式开发模型", "category": "架构", "description": "在软件开发初期只能提供基本需求为前提的渐进式开发模型（如螺旋模型等）。" },
    { "name": "变换模型", "category": "架构", "description": "以形式化开发方法为基础的变换模型。" },
    { "name": "架构风格", "category": "架构", "description": "架构风格（架构模式）是针对给定场景中经常出现的问题提供的一般性可重用解决方案，它反映了领域中众多系统所共有的结构和语义特征，并指导如何将各个模块和子系统有效地组成一个完整的系统。通常，将软件架构风格分成主要五类（David Garland和Mary Shaw划分方式）：数据流风格、调用/返回风格、独立组件风格、虚拟机风格和仓库风格。" },
    { "name": "数据流风格", "category": "架构" },
    { "name": "调用/返回风格", "category": "架构" },
    { "name": "独立组件风格", "category": "架构" },
    { "name": "虚拟机风格", "category": "架构" },
    { "name": "仓库风格", "category": "架构" },
    { "name": "Open Group", "category": "组织" },
    { "name": "ADML", "description": "ADML是一种基于XML的架构描述语言。" },
    { "name": "XML" },
    { "name": "软件生命周期" },
    { "name": "架构模型", "category": "架构" },
    { "name": "分层架构", "category": "架构", "description": "分层架构（Layered Architecture）是最常见的软件架构，也是事实上的标准架构。这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口进行通信。分层架构通常明确约定软件一定要分成多少层，但是，最常见的是四层结构：\n1、表现层（Presentation Layer）：用户界面，负责视觉和用户互动；\n2、业务层（Business Layer）：实现业务逻辑；\n3、持久层（Persistence Layer）：提供数据，SQL语句就放在这一层；\n4、数据库（Database Layer）：保存数据。\n<img src=\"https://regular-files.oss-cn-hangzhou.aliyuncs.com/layered-architecture.jpg\" />\n有的项目在逻辑层和持久层之间加了一个<b>服务层</b>（Service Layer），提供不同业务逻辑需要的一些通用接口。用户的请求将依次通过这四层的处理，不能跳过其中任何一层。" },
    { "name": "事件驱动架构", "category": "架构", "description": "事件（Event）是状态发生变化时软件发出的通知。事件驱动架构（Event-driven Architecture）是通过事件进行通信的软件架构，它分成四个部分：\n<img src=\"https://regular-files.oss-cn-hangzhou.aliyuncs.com/event-driven-architecture.jpg\" />\n1、事件队列（Event Queue）：接收事件的入口；\n2、分发器（Event Mediator）：将不同的事件分发到不同的业务逻辑单元；\n3、事件通道（Event Channel）：分发器与处理器之间的联系渠道；\n4、事件处理器（Event Processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作。\n对于简单的项目，事件队列、分发器和事件通道可以合为一体，整个软件就分成事件代理和事件处理器两部分。\n这是一种流行的分布式异步架构模式，适用于松散耦合系统。" },
    { "name": "微核架构", "category": "架构", "description": "微核架构（Microkernel Architecture）又称为插件架构（Plug-in Architecture），是指软件的内核相对较小，主要功能和业务逻辑都通过插件实现。\n内核（Core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信应该减少到最低，避免出现互相依赖的问题。\n<img src=\"https://regular-files.oss-cn-hangzhou.aliyuncs.com/microkernel-architecture.jpg\" />\n1、核心系统（内核）：负责和具体业务功能无关的通用功能（系统运行的最小功能），例如模块加载、模块间通信等；\n2、插件模块：负责实现具体的业务逻辑，插件是互相独立的，插件之间的通信应该减少到最低，避免出现互相依赖的问题。" },
    { "name": "微服务架构", "category": "架构", "description": "微服务架构（Microservices Architecture）是服务导向架构（Service-Oriented Architecture，SOA）的升级。每一个服务就是一个独立的部署单元（Separately Deployed Unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。\n<img src=\"https://regular-files.oss-cn-hangzhou.aliyuncs.com/microservices-architecture.jpg\" />\n微服务架构分成三种实现模式：\n1、RESTful API模式：服务通过API提供，云服务就属于这一类；\n2、RESTful应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部；\n3、集中消息模式：采用消息代理（Message Broker）可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群。" },
    { "name": "云架构", "category": "架构", "description": "云架构（Cloud Architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。\n它的高扩展性体现在将数据都复制到内存中，变成可复制的内存数据单元，然后将业务处理能力封装成一个个处理单元（Processing Unit）。若访问量增加，就新建处理单元；若访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，需要进行数据持久化。\n云架构主要分成两部分：处理单元（Processing Unit）和虚拟中间件（Virtualized Middleware）。\n<img src=\"https://regular-files.oss-cn-hangzhou.aliyuncs.com/cloud-architecture.jpg\" />\n1、处理单元：实现业务逻辑；\n2、虚拟中间件：负责通信、保持会话控制（sessions）、数据复制、分布式处理和处理单元的部署。\n虚拟中间件又包含四个组件：\n(1) 消息中间件（Messaging Grid）：管理用户请求和会话控制（sessions），当一个请求进来以后，它决定分配给哪一个处理单元。\n(2) 数据处理中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步，保证每个处理单元都得到同样的数据。\n(3) 处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元。\n(4) 部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动负载单元，负载减少，就关闭处理单元。" },
    { "name": "架构建模方法", "category": "架构", "description": "系统架构的常用建模方法，根据建模的侧重点的不同，可以分成四种：结构模型、框架模型、动态模型和过程模型。\n这四种模型并不是完全独立的，通过有机的结合才可形成一个完整的模型来刻画系统架构，也将能更加准确、全面地反映软件架构。" },
    { "name": "结构模型", "category": "架构", "description": "结构模型是最直观、最普遍的建模方法。此方法以架构的构件、连接件和其他概念来刻画结构，并力图通过结构来反映系统的重要语义内容，包括系统的配置、约束、隐含的假设条件、风格和性质。研究结构模型的核心是架构描述语言。" },
    { "name": "框架模型", "category": "架构", "description": "框架模型与结构模型类似，但它不太侧重描述结构的细节，而更侧重整体的架构。架构模型主要以一些特殊的问题为目标建立只针对和适应问题的结构。" },
    { "name": "动态模型", "category": "架构", "description": "动态模型是对结构或框架模型的补充，主要研究系统的“大颗粒”行为的性质。例如，描述系统的重新配置或演化。这里的动态可以是指系统总体结构的配置、建立或拆除通信或计算的过程，这类系统模型常是激励型的。" },
    { "name": "过程模型", "category": "架构", "description": "过程模型是研究构造系统的步骤和过程，其结构是遵循某些过程脚本的结果。" },
    { "name": "Philippe Kruchten", "category": "人物" },
    { "name": "“4+1”架构视图模型", "category": "架构", "description": "Philippe Kruchten在1995年提出了一个“4+1”架构视图模型，从5个不同视图包括逻辑（Logical）视图、过程（Process）视图、物理（Physical）视图、开发（Development）视图和场景（Scenarios）视图来描述软件架构。每一个视图只关心系统的一个侧面，5个视图结合在一起才能够反映系统的软件架构的全部内容。" },
    { "name": "架构应用场景", "category": "架构", "description": "对于现代大型软件，很少使用单一的架构风格进行设计与开发，而是混合多种风格，从不同视角描述大型软件系统的能力，并可保证软件系统的可靠性、可扩展性、可维护性等非功能属性的正确描述。" },
    { "name": "管道-过滤器风格", "category": "架构", "description": "用于将系统分成若干独立的步骤" },
    { "name": "主程序/子系统和面向对象的架构风格", "category": "架构", "description": "用于对组件内部进行设计" },
    { "name": "虚拟机风格", "category": "架构", "description": "用于构造解释器或专家系统" },
    { "name": "C/S和B/S风格", "category": "架构", "description": "适合于数据和处理分布在一定范围，通过网络连接构成系统" },
    { "name": "平台/插件风格", "category": "架构", "description": "用于具有插件扩展功能的应用程序" },
    { "name": "MVC风格", "category": "架构", "description": "用于用户交互程序的设计" },
    { "name": "SOA风格", "category": "架构", "description": "用在企业集成等方面" },
    { "name": "C2风格", "category": "架构", "description": "用于GUI软件开发，用以构件灵活和可扩展的应用系统等" },
    { "name": "可靠性" },
    { "name": "安全性" },
    { "name": "可移植性" },
    { "name": "可扩展性" },
    { "name": "可用性" },
    { "name": "可维护性" },
    { "name": "计算机系统", "category": "计算机", "description": "计算机系统（Computer System）是指用于数据管理的计算机硬件、软件及网络组成的系统。它是按人的要求接收和存储信息，自动进行数据处理和计算，并输出结构信息的机器系统。" },
    { "name": "冯·诺依曼结构计算机", "category": "计算机", "description": "冯·诺依曼结构计算机（Von Neumann machine）" },
    { "name": "处理器", "category": "计算机", "description": "处理器（Central Processing Unit，CPU）" },
    { "name": "指令集", "category": "计算机", "description": "处理器的指令集按照复杂程度可分为复杂指令集与精简指令集" },
    { "name": "复杂指令集", "category": "计算机", "description": "复杂指令集（Complex Instruction Set Computing，CISC）" },
    { "name": "精简指令集", "category": "计算机", "description": "精简指令集（Reduced Instruction Set Computing，RISC）" },
    { "name": "图形处理器", "category": "计算机", "description": "图形处理器（GPU）" },
    { "name": "信号处理器", "category": "计算机", "description": "信号处理器（DSP）" },
    { "name": "现场可编程逻辑门阵", "category": "计算机", "description": "现场可编程逻辑门阵（FPGA）" },
    { "name": "存储器", "category": "计算机", "description": "存储器是利用半导体、磁、光等介质制成用于存储数据的电子设备。" },
    { "name": "存储器硬件结构", "category": "计算机", "description": "根据存储器的硬件结构可以分为SRAM、DRAM、NVRAM、Flash、EPROM、Disk等。" },
    { "name": "SRAM", "category": "计算机" },
    { "name": "DRAM", "category": "计算机" },
    { "name": "NVRAM", "category": "计算机" },
    { "name": "Flash", "category": "计算机" },
    { "name": "EPROM", "category": "计算机" },
    { "name": "Disk", "category": "计算机" },
    { "name": "存储器分层结构", "category": "计算机", "description": "计算机系统中的存储器通常采用分层的体系结构（Merory Hierarchy），按照与处理器的物理距离可分为四个层次：片上缓存、片外缓存、主存（内存）和外存。" },
    { "name": "片上缓存", "category": "计算机", "description": "在处理器核心中直接集成的缓存，SRAM结构，容量小、速度快。" },
    { "name": "片外缓存", "category": "计算机", "description": "在处理器核心外的缓存，需要经过交换互联开关访问，由SRAM构成，容量较片上缓存略大，可以为256KB~4MB。按照层级被称为L2Cache或L3Cache，或者称为平台Cache。" },
    { "name": "主存（内存）", "category": "计算机", "description": "用DRAM结构，以独立的部件/芯片存在，通过总线与处理器连接。DRAM依赖不断充电维持其中的数据，容量在数百MB至数十GB。" },
    { "name": "外存", "category": "计算机", "description": "可以是磁带、磁盘、光盘和各类Flash等介质器件，这类设备访问速度略慢，但容量大，且在掉电后能够保持其数据。" },
    { "name": "OSI参考模型", "category": "网络", "description": "OSI（Open System Interconnect，开放式系统互联）参考模型是ISO组织在1985年研究的网络互连模型。\n该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层）。" },
    { "name": "传输层", "category": "网络" },
    { "name": "TCP协议", "category": "网络" },
    { "name": "UDP协议", "category": "网络" },
    { "name": "IP协议", "category": "网络" },
    { "name": "FTP协议", "category": "网络" },
    { "name": "SMTP协议", "category": "网络", "description": "发邮件，端口25" },
    { "name": "POP3协议", "category": "网络", "description": "收邮件，端口110" },
    { "name": "HTTP协议", "category": "网络" },
    { "name": "HTTP方法", "category": "网络" },
    { "name": "ROS", "category": "嵌入式", "description": "ROS（Robot Operating System，机器人操作系统）" },
    { "name": "ROS1", "category": "嵌入式" },
    { "name": "ROS2", "category": "嵌入式" },
    { "name": "Elasticsearch分词器", "description": "Elasticsearch 分词器" },
    { "name": "Standard分词器" },
    { "name": "Simple分词器" },
    { "name": "Whitespace分词器" },
    { "name": "Keyword分词器" },
    { "name": "RESTful" },
    { "name": "质量属性效用树" },
    { "name": "MTTR" }
  ],
  "edges": [
    { "source": "IEEE 1741-2000", "predicate": "定义", "target": "系统架构", "description": "IEEE 1741-2000标准对架构定义如下：\n<b>架构</b>是体现在<b>组件</b>中的一个系统的基本组织、它们彼此的<b>关系</b>与<b>环境</b>的关系及指导它的设计和发展的<b>原则</b>。\n<b>系统</b>是组织起来完成某一特定功能或一组功能的组件集。系统这个术语包括了单独的应用程序、传统意义上的系统、子系统、系统之系统、产品线、整个企业及感兴趣的其他集合。系统用于完成其环境中的一个或多个任务。\n<b>环境</b>或者上下文决定了对这个系统的开发、运作、政策以及会对系统造成其他影响的环境和设置。\n<b>任务</b>是由一个或者多个利益相关者通过系统达到一些目标的系统的一个用途或操作。" },
    { "source": "系统架构设计师", "target": "系统架构", "description": "系统架构设计师是担任系统架构设计的核心角色。" },
    { "source": "软件架构", "target": "系统架构" },
    { "source": "模块化", "target": "系统架构", "description": "模块化的思想推动软件架构的快速发展。" },
    { "source": "服务导向架构", "predicate": "基于", "target": "模块化" },
    { "source": "组件化", "target": "IEEE 1741-2000", "description": "组件化技术是IEEE 1741-2000标准提出阶段最重要的成果之一。" },
    { "source": "组件化", "predicate": "对比于", "target": "模块化", "description": "组件化开发并不等同于模块化开发。模块化开发只是在逻辑上做了切分，物理上（代码）通常没有真正意义上的隔离。组件化比模块化更独立。" },
    { "source": "组件化", "predicate": "对比于", "target": "应用集成", "description": "组件化不等同于应用集成。组件化比应用集成更紧密。" },
    { "source": "架构描述与表示", "target": "软件架构" },
    { "source": "架构描述语言", "target": "架构描述与表示" },
    { "source": "C2SADL", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "Wright", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "ACME", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "UniCon", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "Rapide", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "Darwin", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "MetaH", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "Aesop", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "Weaves", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "SADL", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "xADL", "predicate": "是一种", "target": "架构描述语言" },
    { "source": "架构分析", "target": "软件架构" },
    { "source": "架构分析方法", "target": "架构分析" },
    { "source": "SAAM", "predicate": "是一种", "target": "架构分析方法" },
    { "source": "ATAM", "predicate": "是一种", "target": "架构分析方法" },
    { "source": "CBAM", "predicate": "是一种", "target": "架构分析方法" },
    { "source": "SBAR", "predicate": "是一种", "target": "架构分析方法" },
    { "source": "ALPSM", "predicate": "是一种", "target": "架构分析方法" },
    { "source": "SAEM", "predicate": "是一种", "target": "架构分析方法" },
    { "source": "架构设计", "target": "软件架构" },
    { "source": "架构设计方法", "target": "架构设计" },
    { "source": "工作驱动", "predicate": "是一种", "target": "架构设计方法" },
    { "source": "用例驱动", "predicate": "是一种", "target": "架构设计方法" },
    { "source": "模式驱动", "predicate": "是一种", "target": "架构设计方法" },
    { "source": "域驱动", "predicate": "是一种", "target": "架构设计方法" },
    { "source": "属性驱动设计", "predicate": "是一种", "target": "架构设计方法" },
    { "source": "架构测试", "target": "软件架构" },
    { "source": "架构测试策略", "target": "架构测试" },
    { "source": "单元测试", "predicate": "是一种", "target": "架构测试策略" },
    { "source": "子系统测试", "predicate": "是一种", "target": "架构测试策略" },
    { "source": "集成测试", "predicate": "是一种", "target": "架构测试策略" },
    { "source": "验收测试", "predicate": "是一种", "target": "架构测试策略" },
    { "source": "架构测试方法", "target": "架构测试" },
    { "source": "架构测试覆盖方法", "predicate": "是一种", "target": "架构测试方法" },
    { "source": "组件设计正确性验证方法", "predicate": "是一种", "target": "架构测试方法" },
    { "source": "基于CHAM的架构动态语义验证方法", "predicate": "是一种", "target": "架构测试方法" },
    { "source": "架构发现", "target": "软件架构" },
    { "source": "迭代架构发现过程", "target": "架构发现" },
    { "source": "架构演化", "target": "软件架构" },
    { "source": "架构适应性", "target": "架构演化" },
    { "source": "架构扩展", "target": "架构演化" },
    { "source": "架构复用", "target": "软件架构" },
    { "source": "架构模式", "target": "架构复用", "description": "架构模式是架构复用的一种成果。" },
    { "source": "开发模型", "target": "软件架构" },
    { "source": "瀑布模型", "predicate": "是一种", "target": "开发模型" },
    { "source": "渐进式开发模型", "predicate": "是一种", "target": "开发模型" },
    { "source": "变换模型", "predicate": "是一种", "target": "开发模型" },
    { "source": "架构风格", "target": "软件架构" },
    { "source": "数据流风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "调用/返回风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "独立组件风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "虚拟机风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "仓库风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "Open Group", "predicate": "提出", "target": "ADML" },
    { "source": "ADML", "predicate": "基于", "target": "XML" },
    { "source": "软件生命周期", "target": "软件架构", "description": "软件架构是软件生命周期中的重要产物，它影响软件开发的各个阶段。\n1、需求阶段：把软件架构有的概念引入需求分析阶段，有助于保证需求规约和系统设计之间的可追踪性和一致性。\n2、设计阶段：设计阶段是软件架构研究关注最早、最多的阶段，这一阶段的软件架构主要包括软件架构的描述、软件架构模型的设计与分析以及对软件架构设计经验的总结与复用等。\n3、实现阶段：将设计阶段设计的算法及数据类型用程序设计语言进行表示，满足设计、架构和需求分析的要求，从而得到满足设计需求的目标系统。\n4、维护阶段：为了保证软件具有良好的维护性，在软件架构中针对维护性目标进行分析时，需要对一些有关维护性的属性（如可扩展性、可替换性）进行规定，当架构经过一定的开发过程实现和形成软件系统时，这些属性也相应地反映了软件的维护性。" },
    { "source": "架构模型", "target": "软件架构" },
    { "source": "分层架构", "target": "架构模型" },
    { "source": "事件驱动架构", "target": "架构模型" },
    { "source": "微核架构", "target": "架构模型" },
    { "source": "微服务架构", "target": "架构模型" },
    { "source": "微服务架构", "predicate": "基于", "target": "服务导向架构", "description": "微服务架构是服务导向架构（Service-Oriented Architecture，SOA）的升级" },
    { "source": "云架构", "target": "架构模型" },
    { "source": "架构建模方法", "target": "软件架构" },
    { "source": "结构模型", "predicate": "是一种", "target": "架构建模方法" },
    { "source": "结构模型", "predicate": "核心是", "target": "架构描述语言" },
    { "source": "框架模型", "predicate": "是一种", "target": "架构建模方法" },
    { "source": "动态模型", "predicate": "是一种", "target": "架构建模方法" },
    { "source": "过程模型", "predicate": "是一种", "target": "架构建模方法" },颈消失了。由于每个处理单元的数据都在内存里，需要进行数据持久化。\n云架构主要分成两部分：处理单元（Processing Unit）和虚拟中间件（Virtualized Middleware）。\n<img src=\"https://regular-files.oss-cn-hangzhou.aliyuncs.com/cloud-architecture.jpg\" />\n1、处理单元：实现业务逻辑；\n2、虚拟中间件：负责通信、保持会话控制（sessions）、数据复制、分布式处理和处理单元的部署。\n虚拟中间件又包含四个组件：\n(1) 消息中间件（Messaging Grid）：管理用户请求和会话控制（sessions），当一个请求进来以后，它决定分配给哪一个处理单元。\n(2) 数据处理中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步，保证每个处理单元都得到同样的数据。\n(3) 处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元。\n(4) 部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动负载单元，负载减少，就关闭处理单元。" },
    { "source": "Philippe Kruchten", "predicate": "提出", "target": "“4+1”架构视图模型" },
    { "source": "“4+1”架构视图模型", "target": "架构建模方法", "description": "四种模型并不是完全独立的，通过有机的结合才可形成一个完整的模型来刻画系统架构，也将能更加准确、全面地反映软件架构。" },
    { "source": "架构应用场景", "target": "软件架构" },
    { "source": "管道-过滤器风格", "target": "架构应用场景", "description": "用于将系统分成若干独立的步骤" },
    { "source": "管道-过滤器风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "主程序/子系统和面向对象的架构风格", "target": "架构应用场景", "description": "用于对组件内部进行设计" },
    { "source": "主程序/子系统和面向对象的架构风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "虚拟机风格", "target": "架构应用场景", "description": "用于构造解释器或专家系统" },
    { "source": "虚拟机风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "C/S和B/S风格", "target": "架构应用场景", "description": "适合于数据和处理分布在一定范围，通过网络连接构成系统" },
    { "source": "C/S和B/S风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "平台/插件风格", "target": "架构应用场景", "description": "用于具有插件扩展功能的应用程序" },
    { "source": "平台/插件风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "MVC风格", "target": "架构应用场景", "description": "用于用户交互程序的设计" },
    { "source": "MVC风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "SOA风格", "target": "架构应用场景", "Description": "用在企业集成等方面" },
    { "source": "SOA风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "C2风格", "target": "架构应用场景", "description": "用于GUI软件开发，用以构件灵活和可扩展的应用系统等" },
    { "source": "C2风格", "predicate": "是一种", "target": "架构风格" },
    { "source": "冯·诺依曼结构计算机", "predicate": "包含", "target": "处理器" },
    { "source": "指令集", "target": "处理器" },
    { "source": "复杂指令集", "predicate": "是一种", "target": "指令集" },
    { "source": "精简指令集", "predicate": "是一种", "target": "指令集" },
    { "source": "复杂指令集", "predicate": "对比于", "target": "精简指令集", "link": "/posts/system-architecture-designer/cisc-vs-risc" },
    { "source": "图形处理器", "predicate": "是一种", "target": "处理器" },
    { "source": "信号处理器", "predicate": "是一种", "target": "处理器" },
    { "source": "现场可编程逻辑门阵", "predicate": "是一种", "target": "处理器" },
    { "source": "冯·诺依曼结构计算机", "predicate": "包含", "target": "存储器" },
    { "source": "存储器", "target": "处理器" },
    { "source": "存储器硬件结构", "target": "存储器" },
    { "source": "SRAM", "target": "存储器硬件结构" },
    { "source": "DRAM", "target": "存储器硬件结构" },
    { "source": "NVRAM", "target": "存储器硬件结构" },
    { "source": "Flash", "target": "存储器硬件结构" },
    { "source": "EPROM", "target": "存储器硬件结构" },
    { "source": "Disk", "target": "存储器硬件结构" },
    { "source": "存储器分层结构", "target": "存储器" },
    { "source": "片上缓存", "target": "存储器分层结构" },
    { "source": "片上缓存", "target": "SRAM" },
    { "source": "片外缓存", "target": "存储器分层结构" },
    { "source": "片外缓存", "target": "SRAM" },
    { "source": "主存（内存）", "target": "存储器分层结构" },
    { "source": "主存（内存）", "target": "DRAM" },
    { "source": "外存", "target": "存储器分层结构" },
    { "source": "传输层", "target": "OSI参考模型" },
    { "source": "TCP协议", "target": "传输层" },
    { "source": "UDP协议", "target": "传输层" },
    { "source": "SMTP协议", "target": "POP3协议" },
    { "source": "ROS1", "target": "ROS" },
    { "source": "ROS2", "target": "ROS" },
    { "source": "Standard分词器", "target": "Elasticsearch分词器" },
    { "source": "Simple分词器", "target": "Elasticsearch分词器" },
    { "source": "Whitespace分词器", "target": "Elasticsearch分词器" },
    { "source": "Keyword分词器", "target": "Elasticsearch分词器" },
    { "source": "RESTful", "target": "HTTP方法" },
    { "source": "HTTP方法", "target": "HTTP协议" }
  ]
}
