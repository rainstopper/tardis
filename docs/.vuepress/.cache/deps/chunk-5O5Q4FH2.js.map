{
  "version": 3,
  "sources": ["../../../../node_modules/echarts/lib/data/DataDiffer.js", "../../../../node_modules/echarts/lib/data/helper/dimensionHelper.js", "../../../../node_modules/echarts/lib/data/SeriesDimensionDefine.js", "../../../../node_modules/echarts/lib/data/SeriesData.js", "../../../../node_modules/echarts/lib/data/helper/createDimensions.js", "../../../../node_modules/echarts/lib/model/referHelper.js", "../../../../node_modules/echarts/lib/chart/helper/createSeriesData.js"],
  "sourcesContent": ["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\nfunction defaultKeyGetter(item) {\n  return item;\n}\nvar DataDiffer = /** @class */function () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context,\n  // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    // Visible in callback via `this.context`;\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      // idx can never be empty array here. see 'set null' logic below.\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      }\n      // Support both `newDataKeyArr` are duplication removed or not removed.\n      newDataIndexMap[newKey] = null;\n    }\n  };\n  DataDiffer.prototype._initIndexMap = function (arr,\n  // Can be null.\n  map,\n  // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n      if (!map) {\n        continue;\n      }\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n  return DataDiffer;\n}();\nexport default DataDiffer;", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, createHashMap, assert, map } from 'zrender/lib/core/util.js';\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nvar DimensionUserOuput = /** @class */function () {\n  function DimensionUserOuput(encode, dimRequest) {\n    this._encode = encode;\n    this._schema = dimRequest;\n  }\n  DimensionUserOuput.prototype.get = function () {\n    return {\n      // Do not generate full dimension name until fist used.\n      fullDimensions: this._getFullDimensionNames(),\n      encode: this._encode\n    };\n  };\n  /**\n   * Get all data store dimension names.\n   * Theoretically a series data store is defined both by series and used dataset (if any).\n   * If some dimensions are omitted for performance reason in `this.dimensions`,\n   * the dimension name may not be auto-generated if user does not specify a dimension name.\n   * In this case, the dimension name is `null`/`undefined`.\n   */\n  DimensionUserOuput.prototype._getFullDimensionNames = function () {\n    if (!this._cachedDimNames) {\n      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];\n    }\n    return this._cachedDimNames;\n  };\n  return DimensionUserOuput;\n}();\n;\nexport function summarizeDimensions(data, schema) {\n  var summary = {};\n  var encode = summary.encode = {};\n  var notExtraCoordDimMap = createHashMap();\n  var defaultedLabel = [];\n  var defaultedTooltip = [];\n  var userOutputEncode = {};\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var coordDim = dimItem.coordDim;\n    if (coordDim) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert(VISUAL_DIMENSIONS.get(coordDim) == null);\n      }\n      var coordDimIndex = dimItem.coordDimIndex;\n      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;\n      if (!dimItem.isExtraCoord) {\n        notExtraCoordDimMap.set(coordDim, 1);\n        // Use the last coord dim (and label friendly) as default label,\n        // because when dataset is used, it is hard to guess which dimension\n        // can be value dimension. If both show x, y on label is not look good,\n        // and conventionally y axis is focused more.\n        if (mayLabelDimType(dimItem.type)) {\n          defaultedLabel[0] = dimName;\n        }\n        // User output encode do not contain generated coords.\n        // And it only has index. User can use index to retrieve value from the raw item array.\n        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);\n      }\n      if (dimItem.defaultTooltip) {\n        defaultedTooltip.push(dimName);\n      }\n    }\n    VISUAL_DIMENSIONS.each(function (v, otherDim) {\n      var encodeArr = getOrCreateEncodeArr(encode, otherDim);\n      var dimIndex = dimItem.otherDims[otherDim];\n      if (dimIndex != null && dimIndex !== false) {\n        encodeArr[dimIndex] = dimItem.name;\n      }\n    });\n  });\n  var dataDimsOnCoord = [];\n  var encodeFirstDimNotExtra = {};\n  notExtraCoordDimMap.each(function (v, coordDim) {\n    var dimArr = encode[coordDim];\n    encodeFirstDimNotExtra[coordDim] = dimArr[0];\n    // Not necessary to remove duplicate, because a data\n    // dim canot on more than one coordDim.\n    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);\n  });\n  summary.dataDimsOnCoord = dataDimsOnCoord;\n  summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function (dimName) {\n    return data.getDimensionInfo(dimName).storeDimIndex;\n  });\n  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;\n  var encodeLabel = encode.label;\n  // FIXME `encode.label` is not recommended, because formatter cannot be set\n  // in this way. Use label.formatter instead. Maybe remove this approach someday.\n  if (encodeLabel && encodeLabel.length) {\n    defaultedLabel = encodeLabel.slice();\n  }\n  var encodeTooltip = encode.tooltip;\n  if (encodeTooltip && encodeTooltip.length) {\n    defaultedTooltip = encodeTooltip.slice();\n  } else if (!defaultedTooltip.length) {\n    defaultedTooltip = defaultedLabel.slice();\n  }\n  encode.defaultedLabel = defaultedLabel;\n  encode.defaultedTooltip = defaultedTooltip;\n  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);\n  return summary;\n}\nfunction getOrCreateEncodeArr(encode, dim) {\n  if (!encode.hasOwnProperty(dim)) {\n    encode[dim] = [];\n  }\n  return encode[dim];\n}\n// FIXME:TS should be type `AxisType`\nexport function getDimensionTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\nfunction mayLabelDimType(dimType) {\n  // In most cases, ordinal and time do not suitable for label.\n  // Ordinal info can be displayed on axis. Time is too long.\n  return !(dimType === 'ordinal' || dimType === 'time');\n}\n// function findTheLastDimMayLabel(data) {\n//     // Get last value dim\n//     let dimensions = data.dimensions.slice();\n//     let valueType;\n//     let valueDim;\n//     while (dimensions.length && (\n//         valueDim = dimensions.pop(),\n//         valueType = data.getDimensionInfo(valueDim).type,\n//         valueType === 'ordinal' || valueType === 'time'\n//     )) {} // jshint ignore:line\n//     return valueDim;\n// }", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nvar SeriesDimensionDefine = /** @class */function () {\n  /**\n   * @param opt All of the fields will be shallow copied.\n   */\n  function SeriesDimensionDefine(opt) {\n    /**\n     * The format of `otherDims` is:\n     * ```js\n     * {\n     *     tooltip?: number\n     *     label?: number\n     *     itemName?: number\n     *     seriesName?: number\n     * }\n     * ```\n     *\n     * A `series.encode` can specified these fields:\n     * ```js\n     * encode: {\n     *     // \"3, 1, 5\" is the index of data dimension.\n     *     tooltip: [3, 1, 5],\n     *     label: [0, 3],\n     *     ...\n     * }\n     * ```\n     * `otherDims` is the parse result of the `series.encode` above, like:\n     * ```js\n     * // Suppose the index of this data dimension is `3`.\n     * this.otherDims = {\n     *     // `3` is at the index `0` of the `encode.tooltip`\n     *     tooltip: 0,\n     *     // `3` is at the index `1` of the `encode.label`\n     *     label: 1\n     * };\n     * ```\n     *\n     * This prop should never be `null`/`undefined` after initialized.\n     */\n    this.otherDims = {};\n    if (opt != null) {\n      zrUtil.extend(this, opt);\n    }\n  }\n  return SeriesDimensionDefine;\n}();\n;\nexport default SeriesDimensionDefine;", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array;\n// Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1;\n// type SeriesDimensionIndex = DimensionIndex;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent'];\n// -----------------------------\n// Internal method declarations:\n// -----------------------------\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\nvar SeriesData = /** @class */function () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = [];\n    // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n    this._visual = {};\n    // Global layout properties.\n    this._layout = {};\n    // Item visual properties after visual coding\n    this._itemVisuals = [];\n    // Item layout properties after layout\n    this._itemLayouts = [];\n    // Graphic elements\n    this._graphicEls = [];\n    // key: dim, value: extent\n    this._approximateExtent = {};\n    this._calculationInfo = {};\n    // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n    this.hasItemOption = false;\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n    this._initGetDimensionInfo(needsHasOwn);\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx == null) {\n      return dim;\n    }\n    dimIdx = dim;\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    }\n    // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n    var dimName = this._dimIdxToName.get(dimIdx);\n    if (dimName != null) {\n      return dimName;\n    }\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n    if (dim == null) {\n      return -1;\n    }\n    var dimInfo = this._getDimInfo(dim);\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim)\n    // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n    var store;\n    if (data instanceof DataStore) {\n      store = data;\n    }\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n    this._store = store;\n    // Reset\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n    this._doInit(0, store.count());\n    // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n      start = _a.start,\n      end = _a.end;\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n    this._updateOrdinalMeta();\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n    var store = this._store;\n    var provider = store.getProvider();\n    this._updateOrdinalMeta();\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;\n    // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n        if (dataItem) {\n          var itemName = dataItem.name;\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n          var itemId = dataItem.id;\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n    if (name == null) {\n      name = '';\n    }\n    return name;\n  };\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n    var rawIndex = invertedIndices[value];\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this;\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n    var val = itemVisual[key];\n    if (val == null) {\n      val = this.getVisual(key);\n      // TODO Performance?\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n      itemVisual[key] = val;\n    }\n    return val;\n  };\n  // eslint-disable-next-line\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n    this.__wrappedMethods = this.__wrappedMethods || [];\n    this.__wrappedMethods.push(methodName);\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  };\n  // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim];\n        // Currently, only dimensions that has ordinalMeta can create inverted indices.\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n          // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n      return id;\n    };\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);\n      // FIXME If needs stackedOn, value may already been stacked\n      transferProperties(list, original);\n      return list;\n    };\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n        idList[idx] = id;\n      }\n    };\n  }();\n  return SeriesData;\n}();\nexport default SeriesData;", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine.js';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { CtorInt32Array } from '../DataStore.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper.js';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema.js';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\nexport default function prepareSeriesDataSchema(\n// TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);\n  // Try to ignore unused dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be displayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n    return resultList[idx];\n  }\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  }\n  // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice();\n    // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  });\n  // Apply templates and default order from `sysDims`.\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta;\n      // `coordDimIndex` should not be set directly.\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n    var dataDims = encodeDefMap.get(coordDim);\n    // negative resultDimIdx means no need to mapping.\n    if (dataDims === false) {\n      return;\n    }\n    dataDims = normalizeToArray(dataDims);\n    // dimensions provides default dim sequences.\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    }\n    // Apply templates.\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx);\n      // Coordinate system has a higher priority on dim type than source.\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      }\n      // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n  // Make sure the first extra dim is 'value'.\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  }\n  // Set dim `name` and other `coordDim` and other props.\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0;\n        // Series specified generateCoord is using out.\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n        generateCoordCount--;\n      }\n      ifNoNameFillWithCoordName(resultItem);\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must\n      // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first column should better be treated as a \"ordinal\" although it\n      // might not be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    });\n    // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n}\n// ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calculate bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\nfunction genCoordDimName(name, map, fromZero) {\n  if (fromZero || map.hasKey(name)) {\n    var i = 0;\n    while (map.hasKey(name + i)) {\n      i++;\n    }\n    name += i;\n  }\n  map.set(name, true);\n  return name;\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n/**\n * Helper for model references.\n * There are many manners to refer axis/coordSys.\n */\n// TODO\n// merge relevant logic to this file?\n// check: \"modelHelper\" of tooltip and \"BrushTargetManager\".\nimport { createHashMap, retrieve, each } from 'zrender/lib/core/util.js';\nimport { SINGLE_REFERRING } from '../util/model.js';\n/**\n * @class\n * For example:\n * {\n *     coordSysName: 'cartesian2d',\n *     coordSysDims: ['x', 'y', ...],\n *     axisMap: HashMap({\n *         x: xAxisModel,\n *         y: yAxisModel\n *     }),\n *     categoryAxisMap: HashMap({\n *         x: xAxisModel,\n *         y: undefined\n *     }),\n *     // The index of the first category axis in `coordSysDims`.\n *     // `null/undefined` means no category axis exists.\n *     firstCategoryDimIndex: 1,\n *     // To replace user specified encode.\n * }\n */\nvar CoordSysInfo = /** @class */function () {\n  function CoordSysInfo(coordSysName) {\n    this.coordSysDims = [];\n    this.axisMap = createHashMap();\n    this.categoryAxisMap = createHashMap();\n    this.coordSysName = coordSysName;\n  }\n  return CoordSysInfo;\n}();\nexport function getCoordSysInfoBySeries(seriesModel) {\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var result = new CoordSysInfo(coordSysName);\n  var fetch = fetchers[coordSysName];\n  if (fetch) {\n    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);\n    return result;\n  }\n}\nvar fetchers = {\n  cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var xAxisModel = seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!xAxisModel) {\n        throw new Error('xAxis \"' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n      }\n      if (!yAxisModel) {\n        throw new Error('yAxis \"' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n      }\n    }\n    result.coordSysDims = ['x', 'y'];\n    axisMap.set('x', xAxisModel);\n    axisMap.set('y', yAxisModel);\n    if (isCategory(xAxisModel)) {\n      categoryAxisMap.set('x', xAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n    if (isCategory(yAxisModel)) {\n      categoryAxisMap.set('y', yAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var singleAxisModel = seriesModel.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!singleAxisModel) {\n        throw new Error('singleAxis should be specified.');\n      }\n    }\n    result.coordSysDims = ['single'];\n    axisMap.set('single', singleAxisModel);\n    if (isCategory(singleAxisModel)) {\n      categoryAxisMap.set('single', singleAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n  },\n  polar: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var polarModel = seriesModel.getReferringComponents('polar', SINGLE_REFERRING).models[0];\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    if (process.env.NODE_ENV !== 'production') {\n      if (!angleAxisModel) {\n        throw new Error('angleAxis option not found');\n      }\n      if (!radiusAxisModel) {\n        throw new Error('radiusAxis option not found');\n      }\n    }\n    result.coordSysDims = ['radius', 'angle'];\n    axisMap.set('radius', radiusAxisModel);\n    axisMap.set('angle', angleAxisModel);\n    if (isCategory(radiusAxisModel)) {\n      categoryAxisMap.set('radius', radiusAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n    if (isCategory(angleAxisModel)) {\n      categoryAxisMap.set('angle', angleAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  geo: function (seriesModel, result, axisMap, categoryAxisMap) {\n    result.coordSysDims = ['lng', 'lat'];\n  },\n  parallel: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var ecModel = seriesModel.ecModel;\n    var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));\n    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();\n    each(parallelModel.parallelAxisIndex, function (axisIndex, index) {\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n      var axisDim = coordSysDims[index];\n      axisMap.set(axisDim, axisModel);\n      if (isCategory(axisModel)) {\n        categoryAxisMap.set(axisDim, axisModel);\n        if (result.firstCategoryDimIndex == null) {\n          result.firstCategoryDimIndex = index;\n        }\n      }\n    });\n  }\n};\nfunction isCategory(axisModel) {\n  return axisModel.get('type') === 'category';\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport SeriesData from '../../data/SeriesData.js';\nimport prepareSeriesDataSchema from '../../data/helper/createDimensions.js';\nimport { getDimensionTypeByAxis } from '../../data/helper/dimensionHelper.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport CoordinateSystem from '../../core/CoordinateSystem.js';\nimport { getCoordSysInfoBySeries } from '../../model/referHelper.js';\nimport { createSourceFromSeriesDataOption } from '../../data/Source.js';\nimport { enableDataStack } from '../../data/helper/dataStackHelper.js';\nimport { makeSeriesEncodeForAxisCoordSys } from '../../data/helper/sourceHelper.js';\nimport { SOURCE_FORMAT_ORIGINAL } from '../../util/types.js';\nfunction getCoordSysDimDefs(seriesModel, coordSysInfo) {\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var registeredCoordSys = CoordinateSystem.get(coordSysName);\n  var coordSysDimDefs;\n  if (coordSysInfo && coordSysInfo.coordSysDims) {\n    coordSysDimDefs = zrUtil.map(coordSysInfo.coordSysDims, function (dim) {\n      var dimInfo = {\n        name: dim\n      };\n      var axisModel = coordSysInfo.axisMap.get(dim);\n      if (axisModel) {\n        var axisType = axisModel.get('type');\n        dimInfo.type = getDimensionTypeByAxis(axisType);\n      }\n      return dimInfo;\n    });\n  }\n  if (!coordSysDimDefs) {\n    // Get dimensions from registered coordinate system\n    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n  }\n  return coordSysDimDefs;\n}\nfunction injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {\n  var firstCategoryDimIndex;\n  var hasNameEncode;\n  coordSysInfo && zrUtil.each(dimInfoList, function (dimInfo, dimIndex) {\n    var coordDim = dimInfo.coordDim;\n    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);\n    if (categoryAxisModel) {\n      if (firstCategoryDimIndex == null) {\n        firstCategoryDimIndex = dimIndex;\n      }\n      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();\n      if (createInvertedIndices) {\n        dimInfo.createInvertedIndices = true;\n      }\n    }\n    if (dimInfo.otherDims.itemName != null) {\n      hasNameEncode = true;\n    }\n  });\n  if (!hasNameEncode && firstCategoryDimIndex != null) {\n    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;\n  }\n  return firstCategoryDimIndex;\n}\n/**\n * Caution: there are side effects to `sourceManager` in this method.\n * Should better only be called in `Series['getInitialData']`.\n */\nfunction createSeriesData(sourceRaw, seriesModel, opt) {\n  opt = opt || {};\n  var sourceManager = seriesModel.getSourceManager();\n  var source;\n  var isOriginalSource = false;\n  if (sourceRaw) {\n    isOriginalSource = true;\n    source = createSourceFromSeriesDataOption(sourceRaw);\n  } else {\n    source = sourceManager.getSource();\n    // Is series.data. not dataset.\n    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;\n  }\n  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);\n  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);\n  var useEncodeDefaulter = opt.useEncodeDefaulter;\n  var encodeDefaulter = zrUtil.isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? zrUtil.curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;\n  var createDimensionOptions = {\n    coordDimensions: coordSysDimDefs,\n    generateCoord: opt.generateCoord,\n    encodeDefine: seriesModel.getEncode(),\n    encodeDefaulter: encodeDefaulter,\n    canOmitUnusedDimensions: !isOriginalSource\n  };\n  var schema = prepareSeriesDataSchema(source, createDimensionOptions);\n  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);\n  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;\n  var stackCalculationInfo = enableDataStack(seriesModel, {\n    schema: schema,\n    store: store\n  });\n  var data = new SeriesData(schema, seriesModel);\n  data.setCalculationInfo(stackCalculationInfo);\n  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // Use dataIndex as ordinal value in categoryAxis\n    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);\n  } : null;\n  data.hasItemOption = false;\n  data.initData(\n  // Try to reuse the data store in sourceManager if using dataset.\n  isOriginalSource ? source : store, null, dimValueGetter);\n  return data;\n}\nfunction isNeedCompleteOrdinalData(source) {\n  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var sampleItem = firstDataNotNull(source.data || []);\n    return !zrUtil.isArray(getDataItemValue(sampleItem));\n  }\n}\nfunction firstDataNotNull(arr) {\n  var i = 0;\n  while (i < arr.length && arr[i] == null) {\n    i++;\n  }\n  return arr[i];\n}\nexport default createSeriesData;"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,SAAS,wBAAwB,4BAA4B;AAC3D,SAAO,8BAA8B,OAAO,IAAI,2BAA2B,UAAU;AACvF;AACA,SAAS,iBAAiB,MAAM;AAC9B,SAAO;AACT;AACA,IAAI;AAAA;AAAA,EAA0B,WAAY;AAIxC,aAASA,YAAW,QAAQ,QAAQ,cAAc,cAAc,SAEhE,UAAU;AACR,WAAK,OAAO;AACZ,WAAK,OAAO;AACZ,WAAK,gBAAgB,gBAAgB;AACrC,WAAK,gBAAgB,gBAAgB;AAErC,WAAK,UAAU;AACf,WAAK,oBAAoB,aAAa;AAAA,IACxC;AAIA,IAAAA,YAAW,UAAU,MAAM,SAAU,MAAM;AACzC,WAAK,OAAO;AACZ,aAAO;AAAA,IACT;AAIA,IAAAA,YAAW,UAAU,SAAS,SAAU,MAAM;AAC5C,WAAK,UAAU;AACf,aAAO;AAAA,IACT;AAIA,IAAAA,YAAW,UAAU,kBAAkB,SAAU,MAAM;AACrD,WAAK,mBAAmB;AACxB,aAAO;AAAA,IACT;AAIA,IAAAA,YAAW,UAAU,kBAAkB,SAAU,MAAM;AACrD,WAAK,mBAAmB;AACxB,aAAO;AAAA,IACT;AAIA,IAAAA,YAAW,UAAU,mBAAmB,SAAU,MAAM;AACtD,WAAK,oBAAoB;AACzB,aAAO;AAAA,IACT;AAIA,IAAAA,YAAW,UAAU,SAAS,SAAU,MAAM;AAC5C,WAAK,UAAU;AACf,aAAO;AAAA,IACT;AACA,IAAAA,YAAW,UAAU,UAAU,WAAY;AACzC,WAAK,KAAK,oBAAoB,qBAAqB,kBAAkB,EAAE;AAAA,IACzE;AACA,IAAAA,YAAW,UAAU,mBAAmB,WAAY;AAClD,UAAI,SAAS,KAAK;AAClB,UAAI,SAAS,KAAK;AAClB,UAAI,kBAAkB,CAAC;AACvB,UAAI,gBAAgB,IAAI,MAAM,OAAO,MAAM;AAC3C,UAAI,gBAAgB,IAAI,MAAM,OAAO,MAAM;AAC3C,WAAK,cAAc,QAAQ,MAAM,eAAe,eAAe;AAC/D,WAAK,cAAc,QAAQ,iBAAiB,eAAe,eAAe;AAC1E,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAI,SAAS,cAAc,CAAC;AAC5B,YAAI,eAAe,gBAAgB,MAAM;AACzC,YAAI,kBAAkB,wBAAwB,YAAY;AAE1D,YAAI,kBAAkB,GAAG;AAGvB,cAAI,SAAS,aAAa,MAAM;AAChC,cAAI,aAAa,WAAW,GAAG;AAC7B,4BAAgB,MAAM,IAAI,aAAa,CAAC;AAAA,UAC1C;AACA,eAAK,WAAW,KAAK,QAAQ,QAAQ,CAAC;AAAA,QACxC,WAAW,oBAAoB,GAAG;AAChC,0BAAgB,MAAM,IAAI;AAC1B,eAAK,WAAW,KAAK,QAAQ,cAAc,CAAC;AAAA,QAC9C,OAAO;AACL,eAAK,WAAW,KAAK,QAAQ,CAAC;AAAA,QAChC;AAAA,MACF;AACA,WAAK,gBAAgB,eAAe,eAAe;AAAA,IACrD;AA0BA,IAAAA,YAAW,UAAU,mBAAmB,WAAY;AAClD,UAAI,SAAS,KAAK;AAClB,UAAI,SAAS,KAAK;AAClB,UAAI,kBAAkB,CAAC;AACvB,UAAI,kBAAkB,CAAC;AACvB,UAAI,gBAAgB,CAAC;AACrB,UAAI,gBAAgB,CAAC;AACrB,WAAK,cAAc,QAAQ,iBAAiB,eAAe,eAAe;AAC1E,WAAK,cAAc,QAAQ,iBAAiB,eAAe,eAAe;AAC1E,eAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,YAAI,SAAS,cAAc,CAAC;AAC5B,YAAI,eAAe,gBAAgB,MAAM;AACzC,YAAI,eAAe,gBAAgB,MAAM;AACzC,YAAI,kBAAkB,wBAAwB,YAAY;AAC1D,YAAI,kBAAkB,wBAAwB,YAAY;AAC1D,YAAI,kBAAkB,KAAK,oBAAoB,GAAG;AAChD,eAAK,oBAAoB,KAAK,iBAAiB,cAAc,YAAY;AACzE,0BAAgB,MAAM,IAAI;AAAA,QAC5B,WAAW,oBAAoB,KAAK,kBAAkB,GAAG;AACvD,eAAK,oBAAoB,KAAK,iBAAiB,cAAc,YAAY;AACzE,0BAAgB,MAAM,IAAI;AAAA,QAC5B,WAAW,oBAAoB,KAAK,oBAAoB,GAAG;AACzD,eAAK,WAAW,KAAK,QAAQ,cAAc,YAAY;AACvD,0BAAgB,MAAM,IAAI;AAAA,QAC5B,WAAW,kBAAkB,KAAK,kBAAkB,GAAG;AACrD,eAAK,qBAAqB,KAAK,kBAAkB,cAAc,YAAY;AAC3E,0BAAgB,MAAM,IAAI;AAAA,QAC5B,WAAW,kBAAkB,GAAG;AAC9B,mBAAS,MAAM,GAAG,MAAM,iBAAiB,OAAO;AAC9C,iBAAK,WAAW,KAAK,QAAQ,aAAa,GAAG,CAAC;AAAA,UAChD;AAAA,QACF,OAAO;AACL,eAAK,WAAW,KAAK,QAAQ,YAAY;AAAA,QAC3C;AAAA,MACF;AACA,WAAK,gBAAgB,eAAe,eAAe;AAAA,IACrD;AACA,IAAAA,YAAW,UAAU,kBAAkB,SAAU,eAAe,iBAAiB;AAC/E,eAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,YAAI,SAAS,cAAc,CAAC;AAC5B,YAAI,eAAe,gBAAgB,MAAM;AACzC,YAAI,eAAe,wBAAwB,YAAY;AACvD,YAAI,eAAe,GAAG;AACpB,mBAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACrC,iBAAK,QAAQ,KAAK,KAAK,aAAa,CAAC,CAAC;AAAA,UACxC;AAAA,QACF,WAAW,iBAAiB,GAAG;AAC7B,eAAK,QAAQ,KAAK,KAAK,YAAY;AAAA,QACrC;AAEA,wBAAgB,MAAM,IAAI;AAAA,MAC5B;AAAA,IACF;AACA,IAAAA,YAAW,UAAU,gBAAgB,SAAU,KAE/CC,MAIA,QAAQ,eAAe;AACrB,UAAI,iBAAiB,KAAK;AAC1B,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AAEnC,YAAI,MAAM,SAAS,KAAK,aAAa,EAAE,IAAI,CAAC,GAAG,CAAC;AAChD,YAAI,CAAC,gBAAgB;AACnB,iBAAO,CAAC,IAAI;AAAA,QACd;AACA,YAAI,CAACA,MAAK;AACR;AAAA,QACF;AACA,YAAI,YAAYA,KAAI,GAAG;AACvB,YAAI,eAAe,wBAAwB,SAAS;AACpD,YAAI,iBAAiB,GAAG;AAGtB,UAAAA,KAAI,GAAG,IAAI;AACX,cAAI,gBAAgB;AAClB,mBAAO,KAAK,GAAG;AAAA,UACjB;AAAA,QACF,WAAW,iBAAiB,GAAG;AAC7B,UAAAA,KAAI,GAAG,IAAI,CAAC,WAAW,CAAC;AAAA,QAC1B,OAAO;AACL,oBAAU,KAAK,CAAC;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AACA,WAAOD;AAAA,EACT,EAAE;AAAA;AACF,IAAO,qBAAQ;;;AC/Mf,IAAI;AAAA;AAAA,EAAkC,WAAY;AAChD,aAASE,oBAAmB,QAAQ,YAAY;AAC9C,WAAK,UAAU;AACf,WAAK,UAAU;AAAA,IACjB;AACA,IAAAA,oBAAmB,UAAU,MAAM,WAAY;AAC7C,aAAO;AAAA;AAAA,QAEL,gBAAgB,KAAK,uBAAuB;AAAA,QAC5C,QAAQ,KAAK;AAAA,MACf;AAAA,IACF;AAQA,IAAAA,oBAAmB,UAAU,yBAAyB,WAAY;AAChE,UAAI,CAAC,KAAK,iBAAiB;AACzB,aAAK,kBAAkB,KAAK,UAAU,KAAK,QAAQ,yBAAyB,IAAI,CAAC;AAAA,MACnF;AACA,aAAO,KAAK;AAAA,IACd;AACA,WAAOA;AAAA,EACT,EAAE;AAAA;AAEK,SAAS,oBAAoB,MAAM,QAAQ;AAChD,MAAI,UAAU,CAAC;AACf,MAAI,SAAS,QAAQ,SAAS,CAAC;AAC/B,MAAI,sBAAsB,cAAc;AACxC,MAAI,iBAAiB,CAAC;AACtB,MAAI,mBAAmB,CAAC;AACxB,MAAI,mBAAmB,CAAC;AACxB,OAAK,KAAK,YAAY,SAAU,SAAS;AACvC,QAAI,UAAU,KAAK,iBAAiB,OAAO;AAC3C,QAAI,WAAW,QAAQ;AACvB,QAAI,UAAU;AACZ,UAAI,MAAuC;AACzC,eAAO,kBAAkB,IAAI,QAAQ,KAAK,IAAI;AAAA,MAChD;AACA,UAAI,gBAAgB,QAAQ;AAC5B,2BAAqB,QAAQ,QAAQ,EAAE,aAAa,IAAI;AACxD,UAAI,CAAC,QAAQ,cAAc;AACzB,4BAAoB,IAAI,UAAU,CAAC;AAKnC,YAAI,gBAAgB,QAAQ,IAAI,GAAG;AACjC,yBAAe,CAAC,IAAI;AAAA,QACtB;AAGA,6BAAqB,kBAAkB,QAAQ,EAAE,aAAa,IAAI,KAAK,kBAAkB,QAAQ,IAAI;AAAA,MACvG;AACA,UAAI,QAAQ,gBAAgB;AAC1B,yBAAiB,KAAK,OAAO;AAAA,MAC/B;AAAA,IACF;AACA,sBAAkB,KAAK,SAAU,GAAG,UAAU;AAC5C,UAAI,YAAY,qBAAqB,QAAQ,QAAQ;AACrD,UAAI,WAAW,QAAQ,UAAU,QAAQ;AACzC,UAAI,YAAY,QAAQ,aAAa,OAAO;AAC1C,kBAAU,QAAQ,IAAI,QAAQ;AAAA,MAChC;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACD,MAAI,kBAAkB,CAAC;AACvB,MAAI,yBAAyB,CAAC;AAC9B,sBAAoB,KAAK,SAAU,GAAG,UAAU;AAC9C,QAAI,SAAS,OAAO,QAAQ;AAC5B,2BAAuB,QAAQ,IAAI,OAAO,CAAC;AAG3C,sBAAkB,gBAAgB,OAAO,MAAM;AAAA,EACjD,CAAC;AACD,UAAQ,kBAAkB;AAC1B,UAAQ,wBAAwB,IAAI,iBAAiB,SAAU,SAAS;AACtE,WAAO,KAAK,iBAAiB,OAAO,EAAE;AAAA,EACxC,CAAC;AACD,UAAQ,yBAAyB;AACjC,MAAI,cAAc,OAAO;AAGzB,MAAI,eAAe,YAAY,QAAQ;AACrC,qBAAiB,YAAY,MAAM;AAAA,EACrC;AACA,MAAI,gBAAgB,OAAO;AAC3B,MAAI,iBAAiB,cAAc,QAAQ;AACzC,uBAAmB,cAAc,MAAM;AAAA,EACzC,WAAW,CAAC,iBAAiB,QAAQ;AACnC,uBAAmB,eAAe,MAAM;AAAA,EAC1C;AACA,SAAO,iBAAiB;AACxB,SAAO,mBAAmB;AAC1B,UAAQ,aAAa,IAAI,mBAAmB,kBAAkB,MAAM;AACpE,SAAO;AACT;AACA,SAAS,qBAAqB,QAAQ,KAAK;AACzC,MAAI,CAAC,OAAO,eAAe,GAAG,GAAG;AAC/B,WAAO,GAAG,IAAI,CAAC;AAAA,EACjB;AACA,SAAO,OAAO,GAAG;AACnB;AAEO,SAAS,uBAAuB,UAAU;AAC/C,SAAO,aAAa,aAAa,YAAY,aAAa,SAAS,SAAS;AAC9E;AACA,SAAS,gBAAgB,SAAS;AAGhC,SAAO,EAAE,YAAY,aAAa,YAAY;AAChD;;;ACnHA,IAAI;AAAA;AAAA,EAAqC,2BAAY;AAInD,aAASC,uBAAsB,KAAK;AAkClC,WAAK,YAAY,CAAC;AAClB,UAAI,OAAO,MAAM;AACf,QAAO,OAAO,MAAM,GAAG;AAAA,MACzB;AAAA,IACF;AACA,WAAOA;AAAA,EACT,EAAE;AAAA;AAEF,IAAO,gCAAQ;;;AClCf,IAAIC,YAAkB;AACtB,IAAIC,OAAa;AACjB,IAAIC,kBAAiB,OAAO,eAAe,cAAc,QAAQ;AAGjE,IAAI,YAAY;AAChB,IAAI,kBAAkB;AAEtB,IAAI,0BAA0B,CAAC,iBAAiB,aAAa,WAAW,uBAAuB,eAAe,cAAc,YAAY,mBAAmB,eAAe,aAAa,kBAAkB;AACzM,IAAI,mBAAmB,CAAC,oBAAoB;AAI5C,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AAAA;AAAA,EAA0B,WAAY;AAMxC,aAASC,YAAW,iBAAiB,WAAW;AAC9C,WAAK,OAAO;AACZ,WAAK,cAAc;AACnB,WAAK,YAAY,CAAC;AAClB,WAAK,UAAU,CAAC;AAKhB,WAAK,UAAU,CAAC;AAEhB,WAAK,UAAU,CAAC;AAEhB,WAAK,eAAe,CAAC;AAErB,WAAK,eAAe,CAAC;AAErB,WAAK,cAAc,CAAC;AAEpB,WAAK,qBAAqB,CAAC;AAC3B,WAAK,mBAAmB,CAAC;AAKzB,WAAK,gBAAgB;AAGrB,WAAK,uBAAuB,CAAC,gBAAgB,cAAc,kBAAkB,KAAK;AAElF,WAAK,oBAAoB,CAAC,cAAc,aAAa;AACrD,WAAK,qBAAqB,CAAC,cAAc,gBAAgB;AACzD,UAAI;AACJ,UAAI,oBAAoB;AACxB,UAAI,mBAAmB,eAAe,GAAG;AACvC,qBAAa,gBAAgB;AAC7B,aAAK,cAAc,gBAAgB,mBAAmB;AACtD,aAAK,UAAU;AAAA,MACjB,OAAO;AACL,4BAAoB;AACpB,qBAAa;AAAA,MACf;AACA,mBAAa,cAAc,CAAC,KAAK,GAAG;AACpC,UAAI,iBAAiB,CAAC;AACtB,UAAI,iBAAiB,CAAC;AACtB,UAAI,qBAAqB,CAAC;AAC1B,UAAI,cAAc;AAClB,UAAI,WAAW,CAAC;AAChB,eAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAE1C,YAAI,eAAe,WAAW,CAAC;AAC/B,YAAI,gBAAuB,SAAS,YAAY,IAAI,IAAI,8BAAsB;AAAA,UAC5E,MAAM;AAAA,QACR,CAAC,IAAI,EAAE,wBAAwB,iCAAyB,IAAI,8BAAsB,YAAY,IAAI;AAClG,YAAI,gBAAgB,cAAc;AAClC,sBAAc,OAAO,cAAc,QAAQ;AAC3C,YAAI,CAAC,cAAc,UAAU;AAC3B,wBAAc,WAAW;AACzB,wBAAc,gBAAgB;AAAA,QAChC;AACA,YAAI,YAAY,cAAc,YAAY,cAAc,aAAa,CAAC;AACtE,uBAAe,KAAK,aAAa;AACjC,uBAAe,aAAa,IAAI;AAChC,YAAI,SAAS,aAAa,KAAK,MAAM;AACnC,wBAAc;AAAA,QAChB;AACA,YAAI,cAAc,uBAAuB;AACvC,6BAAmB,aAAa,IAAI,CAAC;AAAA,QACvC;AACA,YAAI,UAAU,aAAa,GAAG;AAC5B,eAAK,cAAc;AAAA,QACrB;AACA,YAAI,UAAU,WAAW,GAAG;AAC1B,eAAK,YAAY;AAAA,QACnB;AACA,YAAI,MAAuC;AACzC,UAAO,OAAO,qBAAqB,cAAc,iBAAiB,CAAC;AAAA,QACrE;AACA,YAAI,mBAAmB;AACrB,wBAAc,gBAAgB;AAAA,QAChC;AAAA,MACF;AACA,WAAK,aAAa;AAClB,WAAK,YAAY;AACjB,WAAK,sBAAsB,WAAW;AACtC,WAAK,YAAY;AACjB,WAAK,sBAAsB;AAC3B,UAAI,KAAK,aAAa;AACpB,YAAI,iBAAiB,KAAK,gBAAuB,cAAc;AAC/D,QAAO,KAAK,gBAAgB,SAAU,SAAS;AAC7C,yBAAe,IAAI,eAAe,OAAO,EAAE,eAAe,OAAO;AAAA,QACnE,CAAC;AAAA,MACH;AAAA,IACF;AAkBA,IAAAA,YAAW,UAAU,eAAe,SAAU,KAAK;AACjD,UAAI,SAAS,KAAK,mBAAmB,GAAG;AACxC,UAAI,UAAU,MAAM;AAClB,eAAO;AAAA,MACT;AACA,eAAS;AACT,UAAI,CAAC,KAAK,aAAa;AACrB,eAAO,KAAK,WAAW,MAAM;AAAA,MAC/B;AAGA,UAAI,UAAU,KAAK,cAAc,IAAI,MAAM;AAC3C,UAAI,WAAW,MAAM;AACnB,eAAO;AAAA,MACT;AACA,UAAI,eAAe,KAAK,QAAQ,mBAAmB,MAAM;AACzD,UAAI,cAAc;AAChB,eAAO,aAAa;AAAA,MACtB;AAAA,IACF;AAKA,IAAAA,YAAW,UAAU,oBAAoB,SAAU,KAAK;AACtD,UAAI,SAAS,KAAK,mBAAmB,GAAG;AACxC,UAAI,UAAU,MAAM;AAClB,eAAO;AAAA,MACT;AACA,UAAI,OAAO,MAAM;AACf,eAAO;AAAA,MACT;AACA,UAAI,UAAU,KAAK,YAAY,GAAG;AAClC,aAAO,UAAU,QAAQ,gBAAgB,KAAK,cAAc,KAAK,QAAQ,wBAAwB,GAAG,IAAI;AAAA,IAC1G;AAoBA,IAAAA,YAAW,UAAU,qBAAqB,SAAU,KAAK;AACvD,UAAW,SAAS,GAAG,KAEpB,OAAO,QAAQ,CAAC,MAAM,GAAG,KAAK,CAAC,KAAK,YAAY,GAAG,MAAM,CAAC,KAAK,eAAe,KAAK,QAAQ,wBAAwB,GAAG,IAAI,IAAI;AAC/H,eAAO,CAAC;AAAA,MACV;AAAA,IACF;AACA,IAAAA,YAAW,UAAU,oBAAoB,SAAU,KAAK;AACtD,UAAI,SAAS,KAAK,kBAAkB,GAAG;AACvC,UAAI,MAAuC;AACzC,YAAI,UAAU,MAAM;AAClB,gBAAM,IAAI,MAAM,uBAAuB,GAAG;AAAA,QAC5C;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAOA,IAAAA,YAAW,UAAU,mBAAmB,SAAU,KAAK;AAErD,aAAO,KAAK,YAAY,KAAK,aAAa,GAAG,CAAC;AAAA,IAChD;AACA,IAAAA,YAAW,UAAU,wBAAwB,SAAU,aAAa;AAClE,UAAI,iBAAiB,KAAK;AAC1B,WAAK,cAAc,cAAc,SAAU,SAAS;AAClD,eAAO,eAAe,eAAe,OAAO,IAAI,eAAe,OAAO,IAAI;AAAA,MAC5E,IAAI,SAAU,SAAS;AACrB,eAAO,eAAe,OAAO;AAAA,MAC/B;AAAA,IACF;AAIA,IAAAA,YAAW,UAAU,uBAAuB,WAAY;AACtD,aAAO,KAAK,YAAY,gBAAgB,MAAM;AAAA,IAChD;AACA,IAAAA,YAAW,UAAU,eAAe,SAAU,UAAU,KAAK;AAC3D,UAAI,oBAAoB,KAAK;AAC7B,UAAI,OAAO,MAAM;AACf,eAAO,kBAAkB,uBAAuB,QAAQ;AAAA,MAC1D;AACA,UAAI,OAAO,kBAAkB,OAAO,QAAQ;AAC5C,aAAO,OAAO,KAAK,GAAG,IAAI;AAAA,IAC5B;AACA,IAAAA,YAAW,UAAU,mBAAmB,SAAU,UAAU;AAC1D,UAAI,oBAAoB,KAAK;AAC7B,UAAI,OAAO,kBAAkB,OAAO,QAAQ;AAC5C,cAAQ,QAAQ,CAAC,GAAG,MAAM;AAAA,IAC5B;AACA,IAAAA,YAAW,UAAU,WAAW,WAAY;AAC1C,aAAO,KAAK;AAAA,IACd;AAUA,IAAAA,YAAW,UAAU,WAAW,SAAU,MAAM,UAAU,gBAAgB;AACxE,UAAI,QAAQ;AACZ,UAAI;AACJ,UAAI,gBAAgB,mBAAW;AAC7B,gBAAQ;AAAA,MACV;AACA,UAAI,CAAC,OAAO;AACV,YAAI,aAAa,KAAK;AACtB,YAAI,WAAW,iBAAiB,IAAI,KAAY,YAAY,IAAI,IAAI,IAAI,oBAAoB,MAAM,WAAW,MAAM,IAAI;AACvH,gBAAQ,IAAI,kBAAU;AACtB,YAAI,iBAAiBF,KAAI,YAAY,SAAU,SAAS;AACtD,iBAAO;AAAA,YACL,MAAM,MAAM,UAAU,OAAO,EAAE;AAAA,YAC/B,UAAU;AAAA,UACZ;AAAA,QACF,CAAC;AACD,cAAM,SAAS,UAAU,gBAAgB,cAAc;AAAA,MACzD;AACA,WAAK,SAAS;AAEd,WAAK,aAAa,YAAY,CAAC,GAAG,MAAM;AACxC,WAAK,UAAU,CAAC;AAChB,WAAK,mBAAmB,CAAC;AACzB,WAAK,QAAQ,GAAG,MAAM,MAAM,CAAC;AAG7B,WAAK,cAAc,oBAAoB,MAAM,KAAK,OAAO;AACzD,WAAK,aAAa,KAAK,YAAY;AAAA,IACrC;AAIA,IAAAE,YAAW,UAAU,aAAa,SAAU,MAAM;AAChD,UAAI,QAAQ,KAAK,OAAO,WAAW,IAAI;AACvC,WAAK,QAAQ,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,IACjC;AAgBA,IAAAA,YAAW,UAAU,eAAe,SAAU,QAAQ,OAAO;AAC3D,UAAI,KAAK,KAAK,OAAO,aAAa,QAAQ,MAAM,MAAM,GACpD,QAAQ,GAAG,OACX,MAAM,GAAG;AACX,UAAI,uBAAuB,KAAK,sBAAsB;AACtD,WAAK,mBAAmB;AACxB,UAAI,OAAO;AACT,iBAAS,MAAM,OAAO,MAAM,KAAK,OAAO;AACtC,cAAI,YAAY,MAAM;AACtB,eAAK,UAAU,GAAG,IAAI,MAAM,SAAS;AACrC,cAAI,sBAAsB;AACxB,2BAAe,MAAM,GAAG;AAAA,UAC1B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,IAAAA,YAAW,UAAU,qBAAqB,WAAY;AACpD,UAAI,QAAQ,KAAK;AACjB,UAAI,aAAa,KAAK;AACtB,eAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,YAAI,UAAU,KAAK,UAAU,WAAW,CAAC,CAAC;AAC1C,YAAI,QAAQ,aAAa;AACvB,gBAAM,mBAAmB,QAAQ,eAAe,QAAQ,WAAW;AAAA,QACrE;AAAA,MACF;AAAA,IACF;AACA,IAAAA,YAAW,UAAU,wBAAwB,WAAY;AACvD,UAAI,WAAW,KAAK,OAAO,YAAY;AACvC,aAAO,KAAK,aAAa,QAAQ,SAAS,UAAU,EAAE,iBAAiB,6BAA6B,CAAC,SAAS;AAAA,IAChH;AACA,IAAAA,YAAW,UAAU,UAAU,SAAU,OAAO,KAAK;AACnD,UAAI,SAAS,KAAK;AAChB;AAAA,MACF;AACA,UAAI,QAAQ,KAAK;AACjB,UAAI,WAAW,MAAM,YAAY;AACjC,WAAK,mBAAmB;AACxB,UAAI,WAAW,KAAK;AACpB,UAAI,SAAS,KAAK;AAClB,UAAI,eAAe,SAAS,UAAU,EAAE;AACxC,UAAI,mBAAmB,iBAAiB;AASxC,UAAI,oBAAoB,CAAC,SAAS,MAAM;AACtC,YAAI,iBAAiB,CAAC;AACtB,iBAAS,MAAM,OAAO,MAAM,KAAK,OAAO;AAEtC,cAAI,WAAW,SAAS,QAAQ,KAAK,cAAc;AACnD,cAAI,CAAC,KAAK,iBAAiB,iBAAiB,QAAQ,GAAG;AACrD,iBAAK,gBAAgB;AAAA,UACvB;AACA,cAAI,UAAU;AACZ,gBAAI,WAAW,SAAS;AACxB,gBAAI,SAAS,GAAG,KAAK,QAAQ,YAAY,MAAM;AAC7C,uBAAS,GAAG,IAAI,oBAAoB,UAAU,IAAI;AAAA,YACpD;AACA,gBAAI,SAAS,SAAS;AACtB,gBAAI,OAAO,GAAG,KAAK,QAAQ,UAAU,MAAM;AACzC,qBAAO,GAAG,IAAI,oBAAoB,QAAQ,IAAI;AAAA,YAChD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,KAAK,sBAAsB,GAAG;AAChC,iBAAS,MAAM,OAAO,MAAM,KAAK,OAAO;AACtC,yBAAe,MAAM,GAAG;AAAA,QAC1B;AAAA,MACF;AACA,2BAAqB,IAAI;AAAA,IAC3B;AAeA,IAAAA,YAAW,UAAU,uBAAuB,SAAU,KAAK;AACzD,aAAO,KAAK,mBAAmB,GAAG,KAAK,KAAK,OAAO,cAAc,KAAK,kBAAkB,GAAG,CAAC;AAAA,IAC9F;AAKA,IAAAA,YAAW,UAAU,uBAAuB,SAAU,QAAQ,KAAK;AACjE,YAAM,KAAK,aAAa,GAAG;AAC3B,WAAK,mBAAmB,GAAG,IAAI,OAAO,MAAM;AAAA,IAC9C;AACA,IAAAA,YAAW,UAAU,qBAAqB,SAAU,KAAK;AACvD,aAAO,KAAK,iBAAiB,GAAG;AAAA,IAClC;AACA,IAAAA,YAAW,UAAU,qBAAqB,SAAU,KAAK,OAAO;AAC9D,MAAAH,UAAS,GAAG,IAAW,OAAO,KAAK,kBAAkB,GAAG,IAAI,KAAK,iBAAiB,GAAG,IAAI;AAAA,IAC3F;AAOA,IAAAG,YAAW,UAAU,UAAU,SAAU,KAAK;AAC5C,UAAI,WAAW,KAAK,YAAY,GAAG;AACnC,UAAI,OAAO,KAAK,UAAU,QAAQ;AAClC,UAAI,QAAQ,QAAQ,KAAK,eAAe,MAAM;AAC5C,eAAO,mBAAmB,MAAM,KAAK,aAAa,QAAQ;AAAA,MAC5D;AACA,UAAI,QAAQ,MAAM;AAChB,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AACA,IAAAA,YAAW,UAAU,eAAe,SAAU,QAAQ,KAAK;AACzD,UAAI,UAAU,KAAK,OAAO,IAAI,QAAQ,GAAG;AACzC,UAAI,cAAc,KAAK,OAAO,eAAe,MAAM;AACnD,UAAI,aAAa;AACf,eAAO,YAAY,WAAW,OAAO;AAAA,MACvC;AACA,aAAO;AAAA,IACT;AAOA,IAAAA,YAAW,UAAU,QAAQ,SAAU,KAAK;AAC1C,aAAO,MAAM,MAAM,KAAK,YAAY,GAAG,CAAC;AAAA,IAC1C;AACA,IAAAA,YAAW,UAAU,QAAQ,WAAY;AACvC,aAAO,KAAK,OAAO,MAAM;AAAA,IAC3B;AAMA,IAAAA,YAAW,UAAU,MAAM,SAAU,KAAK,KAAK;AAC7C,UAAI,QAAQ,KAAK;AACjB,UAAI,UAAU,KAAK,UAAU,GAAG;AAChC,UAAI,SAAS;AACX,eAAO,MAAM,IAAI,QAAQ,eAAe,GAAG;AAAA,MAC7C;AAAA,IACF;AAIA,IAAAA,YAAW,UAAU,gBAAgB,SAAU,KAAK,QAAQ;AAC1D,UAAI,QAAQ,KAAK;AACjB,UAAI,UAAU,KAAK,UAAU,GAAG;AAChC,UAAI,SAAS;AACX,eAAO,MAAM,cAAc,QAAQ,eAAe,MAAM;AAAA,MAC1D;AAAA,IACF;AACA,IAAAA,YAAW,UAAU,aAAa,WAAY;AAC5C,aAAO,KAAK,OAAO,WAAW;AAAA,IAChC;AACA,IAAAA,YAAW,UAAU,gBAAgB,SAAU,KAAK;AAClD,aAAO,KAAK,OAAO,cAAc,KAAK,kBAAkB,GAAG,CAAC;AAAA,IAC9D;AACA,IAAAA,YAAW,UAAU,SAAS,SAAU,KAAK;AAC3C,aAAO,KAAK,OAAO,OAAO,KAAK,kBAAkB,GAAG,CAAC;AAAA,IACvD;AACA,IAAAA,YAAW,UAAU,YAAY,SAAU,KAAK;AAC9C,aAAO,KAAK,OAAO,UAAU,KAAK,kBAAkB,GAAG,CAAC;AAAA,IAC1D;AACA,IAAAA,YAAW,UAAU,YAAY,SAAU,YAAY,KAAK;AAC1D,UAAI,QAAQ;AACZ,UAAI,QAAQ,KAAK;AACjB,aAAc,QAAQ,UAAU,IAAI,MAAM,UAAUF,KAAI,YAAY,SAAU,KAAK;AACjF,eAAO,MAAM,kBAAkB,GAAG;AAAA,MACpC,CAAC,GAAG,GAAG,IAAI,MAAM,UAAU,UAAU;AAAA,IACvC;AAKA,IAAAE,YAAW,UAAU,WAAW,SAAU,KAAK;AAC7C,UAAI,wBAAwB,KAAK,YAAY;AAC7C,eAAS,IAAI,GAAG,MAAM,sBAAsB,QAAQ,IAAI,KAAK,KAAK;AAIhE,YAAI,MAAM,KAAK,OAAO,IAAI,sBAAsB,CAAC,GAAG,GAAG,CAAC,GAAG;AACzD,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAIA,IAAAA,YAAW,UAAU,cAAc,SAAU,MAAM;AACjD,eAAS,IAAI,GAAG,MAAM,KAAK,OAAO,MAAM,GAAG,IAAI,KAAK,KAAK;AACvD,YAAI,KAAK,QAAQ,CAAC,MAAM,MAAM;AAC5B,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,IAAAA,YAAW,UAAU,cAAc,SAAU,KAAK;AAChD,aAAO,KAAK,OAAO,YAAY,GAAG;AAAA,IACpC;AACA,IAAAA,YAAW,UAAU,kBAAkB,SAAU,UAAU;AACzD,aAAO,KAAK,OAAO,gBAAgB,QAAQ;AAAA,IAC7C;AAQA,IAAAA,YAAW,UAAU,aAAa,SAAU,KAAK,OAAO;AACtD,UAAI,kBAAkB,OAAO,KAAK,oBAAoB,GAAG;AACzD,UAAI,MAAuC;AACzC,YAAI,CAAC,iBAAiB;AACpB,gBAAM,IAAI,MAAM,sBAAsB;AAAA,QACxC;AAAA,MACF;AACA,UAAI,WAAW,gBAAgB,KAAK;AACpC,UAAI,YAAY,QAAQ,MAAM,QAAQ,GAAG;AACvC,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AASA,IAAAA,YAAW,UAAU,mBAAmB,SAAU,KAAK,OAAO,aAAa;AACzE,aAAO,KAAK,OAAO,iBAAiB,KAAK,kBAAkB,GAAG,GAAG,OAAO,WAAW;AAAA,IACrF;AACA,IAAAA,YAAW,UAAU,OAAO,SAAU,MAAM,IAAI,KAAK;AACnD;AAEA,UAAW,WAAW,IAAI,GAAG;AAC3B,cAAM;AACN,aAAK;AACL,eAAO,CAAC;AAAA,MACV;AAEA,UAAI,OAAO,OAAO;AAClB,UAAI,aAAaF,KAAI,oBAAoB,IAAI,GAAG,KAAK,mBAAmB,IAAI;AAC5E,WAAK,OAAO,KAAK,YAAY,OAAc,KAAK,IAAI,IAAI,IAAI,EAAE;AAAA,IAChE;AACA,IAAAE,YAAW,UAAU,aAAa,SAAU,MAAM,IAAI,KAAK;AACzD;AAEA,UAAW,WAAW,IAAI,GAAG;AAC3B,cAAM;AACN,aAAK;AACL,eAAO,CAAC;AAAA,MACV;AAEA,UAAI,OAAO,OAAO;AAClB,UAAI,aAAaF,KAAI,oBAAoB,IAAI,GAAG,KAAK,mBAAmB,IAAI;AAC5E,WAAK,SAAS,KAAK,OAAO,OAAO,YAAY,OAAc,KAAK,IAAI,IAAI,IAAI,EAAE;AAC9E,aAAO;AAAA,IACT;AAKA,IAAAE,YAAW,UAAU,cAAc,SAAU,OAAO;AAClD;AAEA,UAAI,QAAQ;AACZ,UAAI,aAAa,CAAC;AAClB,UAAI,OAAc,KAAK,KAAK;AAC5B,UAAI,aAAa,CAAC;AAClB,MAAO,KAAK,MAAM,SAAU,KAAK;AAC/B,YAAI,SAAS,MAAM,kBAAkB,GAAG;AACxC,mBAAW,MAAM,IAAI,MAAM,GAAG;AAC9B,mBAAW,KAAK,MAAM;AAAA,MACxB,CAAC;AACD,WAAK,SAAS,KAAK,OAAO,YAAY,UAAU;AAChD,aAAO;AAAA,IACT;AAEA,IAAAA,YAAW,UAAU,WAAW,SAAU,MAAM,IAAI,KAAK;AACvD;AAEA,UAAW,WAAW,IAAI,GAAG;AAC3B,cAAM;AACN,aAAK;AACL,eAAO,CAAC;AAAA,MACV;AAEA,YAAM,OAAO;AACb,UAAI,SAAS,CAAC;AACd,WAAK,KAAK,MAAM,WAAY;AAC1B,eAAO,KAAK,MAAM,GAAG,MAAM,MAAM,SAAS,CAAC;AAAA,MAC7C,GAAG,GAAG;AACN,aAAO;AAAA,IACT;AACA,IAAAA,YAAW,UAAU,MAAM,SAAU,MAAM,IAAI,KAAK,WAAW;AAC7D;AAGA,UAAI,OAAO,OAAO,aAAa;AAC/B,UAAI,aAAaF,KAAI,oBAAoB,IAAI,GAAG,KAAK,mBAAmB,IAAI;AAC5E,UAAI,OAAO,yBAAyB,IAAI;AACxC,WAAK,SAAS,KAAK,OAAO,IAAI,YAAY,OAAc,KAAK,IAAI,IAAI,IAAI,EAAE;AAC3E,aAAO;AAAA,IACT;AACA,IAAAE,YAAW,UAAU,SAAS,SAAU,MAAM,IAAI,KAAK,WAAW;AAChE,UAAI,QAAQ;AAEZ,UAAI,OAAO,OAAO,aAAa;AAC/B,UAAI,MAAuC;AACzC,QAAO,KAAK,oBAAoB,IAAI,GAAG,SAAU,KAAK;AACpD,cAAI,UAAU,MAAM,iBAAiB,GAAG;AACxC,cAAI,CAAC,QAAQ,oBAAoB;AAC/B,oBAAQ,MAAM,8CAA8C;AAAA,UAC9D;AAAA,QACF,CAAC;AAAA,MACH;AACA,UAAI,aAAaF,KAAI,oBAAoB,IAAI,GAAG,KAAK,mBAAmB,IAAI;AAK5E,WAAK,OAAO,OAAO,YAAY,OAAc,KAAK,IAAI,IAAI,IAAI,EAAE;AAAA,IAClE;AAKA,IAAAE,YAAW,UAAU,aAAa,SAAU,WAAW,MAAM,aAAa,aAAa;AACrF,UAAI,OAAO,yBAAyB,IAAI;AACxC,WAAK,SAAS,KAAK,OAAO,WAAW,KAAK,kBAAkB,SAAS,GAAG,MAAM,aAAa,WAAW;AACtG,aAAO;AAAA,IACT;AAMA,IAAAA,YAAW,UAAU,iBAAiB,SAAU,gBAAgB,MAAM;AACpE,UAAI,OAAO,yBAAyB,IAAI;AACxC,WAAK,SAAS,KAAK,OAAO,eAAe,KAAK,kBAAkB,cAAc,GAAG,IAAI;AACrF,aAAO;AAAA,IACT;AACA,IAAAA,YAAW,UAAU,iBAAiB,SAAU,KAAK;AACnD,aAAO,KAAK,OAAO,eAAe,GAAG;AAAA,IACvC;AAKA,IAAAA,YAAW,UAAU,eAAe,SAAU,KAAK;AACjD,UAAI,YAAY,KAAK;AACrB,UAAI,WAAW,KAAK,eAAe,GAAG;AACtC,aAAO,IAAI,cAAM,UAAU,WAAW,aAAa,UAAU,OAAO;AAAA,IACtE;AAIA,IAAAA,YAAW,UAAU,OAAO,SAAU,WAAW;AAC/C,UAAI,WAAW;AACf,aAAO,IAAI,mBAAW,YAAY,UAAU,SAAS,EAAE,WAAW,IAAI,CAAC,GAAG,KAAK,SAAS,EAAE,WAAW,GAAG,SAAU,KAAK;AACrH,eAAO,MAAM,WAAW,GAAG;AAAA,MAC7B,GAAG,SAAU,KAAK;AAChB,eAAO,MAAM,UAAU,GAAG;AAAA,MAC5B,CAAC;AAAA,IACH;AAIA,IAAAA,YAAW,UAAU,YAAY,SAAU,KAAK;AAC9C,UAAI,SAAS,KAAK;AAClB,aAAO,UAAU,OAAO,GAAG;AAAA,IAC7B;AACA,IAAAA,YAAW,UAAU,YAAY,SAAU,OAAO,KAAK;AACrD,WAAK,UAAU,KAAK,WAAW,CAAC;AAChC,UAAIH,UAAS,KAAK,GAAG;AACnB,QAAO,OAAO,KAAK,SAAS,KAAK;AAAA,MACnC,OAAO;AACL,aAAK,QAAQ,KAAK,IAAI;AAAA,MACxB;AAAA,IACF;AAKA,IAAAG,YAAW,UAAU,gBAAgB,SAAU,KAAK,KAAK;AACvD,UAAI,aAAa,KAAK,aAAa,GAAG;AACtC,UAAI,MAAM,cAAc,WAAW,GAAG;AACtC,UAAI,OAAO,MAAM;AAEf,eAAO,KAAK,UAAU,GAAG;AAAA,MAC3B;AACA,aAAO;AAAA,IACT;AAIA,IAAAA,YAAW,UAAU,gBAAgB,WAAY;AAC/C,aAAO,KAAK,aAAa,SAAS;AAAA,IACpC;AAKA,IAAAA,YAAW,UAAU,yBAAyB,SAAU,KAAK,KAAK;AAChE,UAAI,cAAc,KAAK;AACvB,UAAI,aAAa,YAAY,GAAG;AAChC,UAAI,CAAC,YAAY;AACf,qBAAa,YAAY,GAAG,IAAI,CAAC;AAAA,MACnC;AACA,UAAI,MAAM,WAAW,GAAG;AACxB,UAAI,OAAO,MAAM;AACf,cAAM,KAAK,UAAU,GAAG;AAExB,YAAW,QAAQ,GAAG,GAAG;AACvB,gBAAM,IAAI,MAAM;AAAA,QAClB,WAAWH,UAAS,GAAG,GAAG;AACxB,gBAAa,OAAO,CAAC,GAAG,GAAG;AAAA,QAC7B;AACA,mBAAW,GAAG,IAAI;AAAA,MACpB;AACA,aAAO;AAAA,IACT;AAEA,IAAAG,YAAW,UAAU,gBAAgB,SAAU,KAAK,KAAK,OAAO;AAC9D,UAAI,aAAa,KAAK,aAAa,GAAG,KAAK,CAAC;AAC5C,WAAK,aAAa,GAAG,IAAI;AACzB,UAAIH,UAAS,GAAG,GAAG;AACjB,QAAO,OAAO,YAAY,GAAG;AAAA,MAC/B,OAAO;AACL,mBAAW,GAAG,IAAI;AAAA,MACpB;AAAA,IACF;AAIA,IAAAG,YAAW,UAAU,iBAAiB,WAAY;AAChD,WAAK,UAAU,CAAC;AAChB,WAAK,eAAe,CAAC;AAAA,IACvB;AACA,IAAAA,YAAW,UAAU,YAAY,SAAU,KAAK,KAAK;AACnD,MAAAH,UAAS,GAAG,IAAW,OAAO,KAAK,SAAS,GAAG,IAAI,KAAK,QAAQ,GAAG,IAAI;AAAA,IACzE;AAIA,IAAAG,YAAW,UAAU,YAAY,SAAU,KAAK;AAC9C,aAAO,KAAK,QAAQ,GAAG;AAAA,IACzB;AAIA,IAAAA,YAAW,UAAU,gBAAgB,SAAU,KAAK;AAClD,aAAO,KAAK,aAAa,GAAG;AAAA,IAC9B;AAIA,IAAAA,YAAW,UAAU,gBAAgB,SAAU,KAAK,QAAQ,OAAO;AACjE,WAAK,aAAa,GAAG,IAAI,QAAe,OAAO,KAAK,aAAa,GAAG,KAAK,CAAC,GAAG,MAAM,IAAI;AAAA,IACzF;AAIA,IAAAA,YAAW,UAAU,mBAAmB,WAAY;AAClD,WAAK,aAAa,SAAS;AAAA,IAC7B;AAIA,IAAAA,YAAW,UAAU,mBAAmB,SAAU,KAAK,IAAI;AACzD,UAAI,cAAc,KAAK,aAAa,KAAK,UAAU;AACnD,sBAAgB,aAAa,KAAK,UAAU,KAAK,EAAE;AACnD,WAAK,YAAY,GAAG,IAAI;AAAA,IAC1B;AACA,IAAAA,YAAW,UAAU,mBAAmB,SAAU,KAAK;AACrD,aAAO,KAAK,YAAY,GAAG;AAAA,IAC7B;AACA,IAAAA,YAAW,UAAU,oBAAoB,SAAU,IAAI,SAAS;AAC9D,MAAO,KAAK,KAAK,aAAa,SAAU,IAAI,KAAK;AAC/C,YAAI,IAAI;AACN,gBAAM,GAAG,KAAK,SAAS,IAAI,GAAG;AAAA,QAChC;AAAA,MACF,CAAC;AAAA,IACH;AAKA,IAAAA,YAAW,UAAU,eAAe,SAAU,MAAM;AAClD,UAAI,CAAC,MAAM;AACT,eAAO,IAAIA,YAAW,KAAK,UAAU,KAAK,UAAUF,KAAI,KAAK,YAAY,KAAK,aAAa,IAAI,GAAG,KAAK,SAAS;AAAA,MAClH;AACA,yBAAmB,MAAM,IAAI;AAC7B,WAAK,SAAS,KAAK;AACnB,aAAO;AAAA,IACT;AAIA,IAAAE,YAAW,UAAU,aAAa,SAAU,YAAY,gBAAgB;AACtE,UAAI,iBAAiB,KAAK,UAAU;AACpC,UAAI,CAAQ,WAAW,cAAc,GAAG;AACtC;AAAA,MACF;AACA,WAAK,mBAAmB,KAAK,oBAAoB,CAAC;AAClD,WAAK,iBAAiB,KAAK,UAAU;AACrC,WAAK,UAAU,IAAI,WAAY;AAC7B,YAAI,MAAM,eAAe,MAAM,MAAM,SAAS;AAC9C,eAAO,eAAe,MAAM,MAAM,CAAC,GAAG,EAAE,OAAc,MAAM,SAAS,CAAC,CAAC;AAAA,MACzE;AAAA,IACF;AAIA,IAAAA,YAAW,gBAAgB,WAAY;AACrC,6BAAuB,SAAU,MAAM;AACrC,YAAI,qBAAqB,KAAK;AAC9B,QAAO,KAAK,oBAAoB,SAAU,iBAAiB,KAAK;AAC9D,cAAI,UAAU,KAAK,UAAU,GAAG;AAEhC,cAAI,cAAc,QAAQ;AAC1B,cAAI,QAAQ,KAAK;AACjB,cAAI,aAAa;AACf,8BAAkB,mBAAmB,GAAG,IAAI,IAAID,gBAAe,YAAY,WAAW,MAAM;AAG5F,qBAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC/C,8BAAgB,CAAC,IAAI;AAAA,YACvB;AACA,qBAAS,IAAI,GAAG,IAAI,MAAM,MAAM,GAAG,KAAK;AAEtC,8BAAgB,MAAM,IAAI,QAAQ,eAAe,CAAC,CAAC,IAAI;AAAA,YACzD;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AACA,2BAAqB,SAAU,MAAM,QAAQ,KAAK;AAChD,eAAO,oBAAoB,KAAK,aAAa,QAAQ,GAAG,GAAG,IAAI;AAAA,MACjE;AAIA,cAAQ,SAAU,MAAM,UAAU;AAChC,YAAI,KAAK,KAAK,QAAQ,QAAQ;AAC9B,YAAI,MAAM,QAAQ,KAAK,aAAa,MAAM;AACxC,eAAK,mBAAmB,MAAM,KAAK,WAAW,QAAQ;AAAA,QACxD;AACA,YAAI,MAAM,MAAM;AACd,eAAK,YAAY;AAAA,QACnB;AACA,eAAO;AAAA,MACT;AACA,4BAAsB,SAAU,YAAY;AAC1C,YAAI,CAAQ,QAAQ,UAAU,GAAG;AAC/B,uBAAa,cAAc,OAAO,CAAC,UAAU,IAAI,CAAC;AAAA,QACpD;AACA,eAAO;AAAA,MACT;AAIA,iCAA2B,SAAU,UAAU;AAC7C,YAAI,OAAO,IAAIC,YAAW,SAAS,UAAU,SAAS,UAAUF,KAAI,SAAS,YAAY,SAAS,aAAa,QAAQ,GAAG,SAAS,SAAS;AAE5I,2BAAmB,MAAM,QAAQ;AACjC,eAAO;AAAA,MACT;AACA,2BAAqB,SAAU,QAAQ,QAAQ;AAC7C,QAAO,KAAK,wBAAwB,OAAO,OAAO,oBAAoB,CAAC,CAAC,GAAG,SAAU,UAAU;AAC7F,cAAI,OAAO,eAAe,QAAQ,GAAG;AACnC,mBAAO,QAAQ,IAAI,OAAO,QAAQ;AAAA,UACpC;AAAA,QACF,CAAC;AACD,eAAO,mBAAmB,OAAO;AACjC,QAAO,KAAK,kBAAkB,SAAU,UAAU;AAChD,iBAAO,QAAQ,IAAW,MAAM,OAAO,QAAQ,CAAC;AAAA,QAClD,CAAC;AACD,eAAO,mBAA0B,OAAO,CAAC,GAAG,OAAO,gBAAgB;AAAA,MACrE;AACA,uBAAiB,SAAU,MAAM,KAAK;AACpC,YAAI,WAAW,KAAK;AACpB,YAAI,SAAS,KAAK;AAClB,YAAI,aAAa,KAAK;AACtB,YAAI,WAAW,KAAK;AACpB,YAAI,OAAO,SAAS,GAAG;AACvB,YAAI,KAAK,OAAO,GAAG;AACnB,YAAI,QAAQ,QAAQ,cAAc,MAAM;AACtC,mBAAS,GAAG,IAAI,OAAO,mBAAmB,MAAM,YAAY,GAAG;AAAA,QACjE;AACA,YAAI,MAAM,QAAQ,YAAY,MAAM;AAClC,iBAAO,GAAG,IAAI,KAAK,mBAAmB,MAAM,UAAU,GAAG;AAAA,QAC3D;AACA,YAAI,MAAM,QAAQ,QAAQ,MAAM;AAC9B,cAAI,kBAAkB,KAAK;AAC3B,cAAI,QAAQ,gBAAgB,IAAI,KAAK,gBAAgB,IAAI,KAAK,KAAK;AACnE,eAAK;AACL,cAAI,QAAQ,GAAG;AACb,kBAAM,WAAW;AAAA,UACnB;AACA,iBAAO,GAAG,IAAI;AAAA,QAChB;AAAA,MACF;AAAA,IACF,EAAE;AACF,WAAOE;AAAA,EACT,EAAE;AAAA;AACF,IAAO,qBAAQ;;;ACp6BR,SAAS,iBAAiB,QAAQ,KAAK;AAC5C,SAAO,wBAAwB,QAAQ,GAAG,EAAE;AAC9C;AAae,SAAR,wBAEP,QAAQ,KAAK;AACX,MAAI,CAAC,iBAAiB,MAAM,GAAG;AAC7B,aAAS,iCAAiC,MAAM;AAAA,EAClD;AACA,QAAM,OAAO,CAAC;AACd,MAAI,UAAU,IAAI,mBAAmB,CAAC;AACtC,MAAI,UAAU,IAAI,oBAAoB,OAAO,oBAAoB,CAAC;AAClE,MAAI,kBAAkB,cAAc;AACpC,MAAI,aAAa,CAAC;AAClB,MAAI,WAAW,YAAY,QAAQ,SAAS,SAAS,IAAI,eAAe;AAGxE,MAAI,uBAAuB,IAAI,2BAA2B,2BAA2B,QAAQ;AAC7F,MAAI,6BAA6B,YAAY,OAAO;AACpD,MAAI,iBAAiB,6BAA6B,uBAAuB,MAAM,IAAI,iBAAiB,OAAO;AAC3G,MAAI,YAAY,IAAI;AACpB,MAAI,CAAC,aAAa,IAAI,iBAAiB;AACrC,gBAAY,IAAI,gBAAgB,QAAQ,QAAQ;AAAA,EAClD;AACA,MAAI,eAAe,cAAc,SAAS;AAC1C,MAAI,aAAa,IAAI,eAAe,QAAQ;AAC5C,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,eAAW,CAAC,IAAI;AAAA,EAClB;AACA,WAAS,cAAc,QAAQ;AAC7B,QAAI,MAAM,WAAW,MAAM;AAC3B,QAAI,MAAM,GAAG;AACX,UAAI,gBAAgB,QAAQ,MAAM;AAClC,UAAI,aAAa,SAAS,aAAa,IAAI,gBAAgB;AAAA,QACzD,MAAM;AAAA,MACR;AACA,UAAIC,cAAa,IAAI,8BAAsB;AAC3C,UAAI,cAAc,WAAW;AAC7B,UAAI,eAAe,QAAQ,eAAe,IAAI,WAAW,KAAK,MAAM;AAIlE,QAAAA,YAAW,OAAOA,YAAW,cAAc;AAAA,MAC7C;AACA,iBAAW,QAAQ,SAASA,YAAW,OAAO,WAAW;AACzD,iBAAW,eAAe,SAASA,YAAW,cAAc,WAAW;AACvE,UAAI,SAAS,WAAW;AACxB,iBAAW,MAAM,IAAI;AACrB,MAAAA,YAAW,gBAAgB;AAC3B,iBAAW,KAAKA,WAAU;AAC1B,aAAOA;AAAA,IACT;AACA,WAAO,WAAW,GAAG;AAAA,EACvB;AACA,MAAI,CAAC,sBAAsB;AACzB,aAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,oBAAc,CAAC;AAAA,IACjB;AAAA,EACF;AAEA,eAAa,KAAK,SAAU,aAAaC,WAAU;AACjD,QAAI,WAAW,iBAAiB,WAAW,EAAE,MAAM;AAInD,QAAI,SAAS,WAAW,KAAK,CAAC,SAAS,SAAS,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI,GAAG;AACtE,mBAAa,IAAIA,WAAU,KAAK;AAChC;AAAA,IACF;AACA,QAAI,gBAAgB,aAAa,IAAIA,WAAU,CAAC,CAAC;AACjD,SAAK,UAAU,SAAU,oBAAoB,KAAK;AAEhD,UAAIC,gBAAe,SAAS,kBAAkB,IAAI,eAAe,IAAI,kBAAkB,IAAI;AAC3F,UAAIA,iBAAgB,QAAQA,gBAAe,UAAU;AACnD,sBAAc,GAAG,IAAIA;AACrB,iBAAS,cAAcA,aAAY,GAAGD,WAAU,GAAG;AAAA,MACrD;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AAED,MAAI,cAAc;AAClB,OAAK,SAAS,SAAU,eAAe;AACrC,QAAIA;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,SAAS,aAAa,GAAG;AAC3B,MAAAA,YAAW;AACX,mBAAa,CAAC;AAAA,IAChB,OAAO;AACL,mBAAa;AACb,MAAAA,YAAW,WAAW;AACtB,UAAI,cAAc,WAAW;AAC7B,iBAAW,cAAc;AACzB,mBAAa,OAAO,CAAC,GAAG,UAAU;AAClC,iBAAW,cAAc;AAEzB,0BAAoB,WAAW;AAC/B,4BAAsB,WAAW;AACjC,iBAAW,OAAO,WAAW,WAAW,WAAW,gBAAgB,WAAW,UAAU,WAAW,YAAY;AAAA,IACjH;AACA,QAAI,WAAW,aAAa,IAAIA,SAAQ;AAExC,QAAI,aAAa,OAAO;AACtB;AAAA,IACF;AACA,eAAW,iBAAiB,QAAQ;AAEpC,QAAI,CAAC,SAAS,QAAQ;AACpB,eAASE,KAAI,GAAGA,MAAK,qBAAqB,kBAAkB,UAAU,IAAIA,MAAK;AAC7E,eAAO,cAAc,YAAY,cAAc,WAAW,EAAE,YAAY,MAAM;AAC5E;AAAA,QACF;AACA,sBAAc,YAAY,SAAS,KAAK,aAAa;AAAA,MACvD;AAAA,IACF;AAEA,SAAK,UAAU,SAAUD,eAAc,eAAe;AACpD,UAAIF,cAAa,cAAcE,aAAY;AAE3C,UAAI,8BAA8B,WAAW,QAAQ,MAAM;AACzD,QAAAF,YAAW,OAAO,WAAW;AAAA,MAC/B;AACA,eAAS,SAASA,aAAY,UAAU,GAAGC,WAAU,aAAa;AAClE,UAAID,YAAW,QAAQ,QAAQ,mBAAmB;AAChD,YAAI,wBAAwB,kBAAkB,aAAa;AAC3D,SAAC,SAAS,qBAAqB,MAAM,wBAAwB;AAAA,UAC3D,MAAM;AAAA,QACR;AACA,QAAAA,YAAW,OAAOA,YAAW,cAAc,sBAAsB;AACjE,QAAAA,YAAW,iBAAiB,sBAAsB;AAAA,MACpD;AAEA,6BAAuB,SAASA,YAAW,WAAW,mBAAmB;AAAA,IAC3E,CAAC;AAAA,EACH,CAAC;AACD,WAAS,SAASA,aAAYC,WAAU,eAAe;AACrD,QAAI,kBAAkB,IAAIA,SAAQ,KAAK,MAAM;AAC3C,MAAAD,YAAW,UAAUC,SAAQ,IAAI;AAAA,IACnC,OAAO;AACL,MAAAD,YAAW,WAAWC;AACtB,MAAAD,YAAW,gBAAgB;AAC3B,sBAAgB,IAAIC,WAAU,IAAI;AAAA,IACpC;AAAA,EACF;AAEA,MAAI,gBAAgB,IAAI;AACxB,MAAI,qBAAqB,IAAI;AAC7B,MAAI,WAAW,sBAAsB;AACrC,uBAAqB,gBAAgB,sBAAsB,IAAI;AAC/D,MAAI,QAAQ,iBAAiB;AAC7B,WAAS,0BAA0BD,aAAY;AAC7C,QAAIA,YAAW,QAAQ,MAAM;AAE3B,MAAAA,YAAW,OAAOA,YAAW;AAAA,IAC/B;AAAA,EACF;AAEA,MAAI,CAAC,sBAAsB;AACzB,aAAS,eAAe,GAAG,eAAe,UAAU,gBAAgB;AAClE,UAAI,aAAa,cAAc,YAAY;AAC3C,UAAI,WAAW,WAAW;AAC1B,UAAI,YAAY,MAAM;AAEpB,mBAAW,WAAW,gBAAgB,OAAO,iBAAiB,QAAQ;AACtE,mBAAW,gBAAgB;AAE3B,YAAI,CAAC,iBAAiB,sBAAsB,GAAG;AAC7C,qBAAW,eAAe;AAAA,QAC5B;AACA;AAAA,MACF;AACA,gCAA0B,UAAU;AACpC,UAAI,WAAW,QAAQ,SAAS,aAAa,QAAQ,YAAY,MAAM,WAAW,QAa/E,WAAW,iBAAiB,WAAW,UAAU,YAAY,QAAQ,WAAW,UAAU,cAAc,QAAQ;AACjH,mBAAW,OAAO;AAAA,MACpB;AAAA,IACF;AAAA,EACF,OAAO;AACL,SAAK,YAAY,SAAUA,aAAY;AAErC,gCAA0BA,WAAU;AAAA,IACtC,CAAC;AAGD,eAAW,KAAK,SAAU,OAAO,OAAO;AACtC,aAAO,MAAM,gBAAgB,MAAM;AAAA,IACrC,CAAC;AAAA,EACH;AACA,oBAAkB,UAAU;AAC5B,SAAO,IAAI,iBAAiB;AAAA,IAC1B;AAAA,IACA,YAAY;AAAA,IACZ,oBAAoB;AAAA,IACpB,kBAAkB;AAAA,EACpB,CAAC;AACH;AACA,SAAS,kBAAkB,QAAQ;AACjC,MAAI,iBAAiB,cAAc;AACnC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,MAAM,OAAO,CAAC;AAClB,QAAI,kBAAkB,IAAI;AAC1B,QAAI,QAAQ,eAAe,IAAI,eAAe,KAAK;AACnD,QAAI,QAAQ,GAAG;AAEb,UAAI,OAAO,mBAAmB,QAAQ;AAAA,IACxC;AACA;AACA,mBAAe,IAAI,iBAAiB,KAAK;AAAA,EAC3C;AACF;AAWA,SAAS,YAAY,QAAQ,SAAS,SAAS,aAAa;AAG1D,MAAI,WAAW,KAAK,IAAI,OAAO,2BAA2B,GAAG,QAAQ,QAAQ,QAAQ,QAAQ,eAAe,CAAC;AAC7G,OAAK,SAAS,SAAU,YAAY;AAClC,QAAI;AACJ,QAAI,SAAS,UAAU,MAAM,oBAAoB,WAAW,UAAU;AACpE,iBAAW,KAAK,IAAI,UAAU,kBAAkB,MAAM;AAAA,IACxD;AAAA,EACF,CAAC;AACD,SAAO;AACT;AACA,SAAS,gBAAgB,MAAMI,MAAK,UAAU;AAC5C,MAAI,YAAYA,KAAI,OAAO,IAAI,GAAG;AAChC,QAAI,IAAI;AACR,WAAOA,KAAI,OAAO,OAAO,CAAC,GAAG;AAC3B;AAAA,IACF;AACA,YAAQ;AAAA,EACV;AACA,EAAAA,KAAI,IAAI,MAAM,IAAI;AAClB,SAAO;AACT;;;ACzPA,IAAI;AAAA;AAAA,EAA4B,2BAAY;AAC1C,aAASC,cAAa,cAAc;AAClC,WAAK,eAAe,CAAC;AACrB,WAAK,UAAU,cAAc;AAC7B,WAAK,kBAAkB,cAAc;AACrC,WAAK,eAAe;AAAA,IACtB;AACA,WAAOA;AAAA,EACT,EAAE;AAAA;AACK,SAAS,wBAAwB,aAAa;AACnD,MAAI,eAAe,YAAY,IAAI,kBAAkB;AACrD,MAAI,SAAS,IAAI,aAAa,YAAY;AAC1C,MAAI,QAAQ,SAAS,YAAY;AACjC,MAAI,OAAO;AACT,UAAM,aAAa,QAAQ,OAAO,SAAS,OAAO,eAAe;AACjE,WAAO;AAAA,EACT;AACF;AACA,IAAI,WAAW;AAAA,EACb,aAAa,SAAU,aAAa,QAAQ,SAAS,iBAAiB;AACpE,QAAI,aAAa,YAAY,uBAAuB,SAAS,gBAAgB,EAAE,OAAO,CAAC;AACvF,QAAI,aAAa,YAAY,uBAAuB,SAAS,gBAAgB,EAAE,OAAO,CAAC;AACvF,QAAI,MAAuC;AACzC,UAAI,CAAC,YAAY;AACf,cAAM,IAAI,MAAM,YAAY,SAAS,YAAY,IAAI,YAAY,GAAG,YAAY,IAAI,SAAS,GAAG,CAAC,IAAI,aAAa;AAAA,MACpH;AACA,UAAI,CAAC,YAAY;AACf,cAAM,IAAI,MAAM,YAAY,SAAS,YAAY,IAAI,YAAY,GAAG,YAAY,IAAI,SAAS,GAAG,CAAC,IAAI,aAAa;AAAA,MACpH;AAAA,IACF;AACA,WAAO,eAAe,CAAC,KAAK,GAAG;AAC/B,YAAQ,IAAI,KAAK,UAAU;AAC3B,YAAQ,IAAI,KAAK,UAAU;AAC3B,QAAI,WAAW,UAAU,GAAG;AAC1B,sBAAgB,IAAI,KAAK,UAAU;AACnC,aAAO,wBAAwB;AAAA,IACjC;AACA,QAAI,WAAW,UAAU,GAAG;AAC1B,sBAAgB,IAAI,KAAK,UAAU;AACnC,aAAO,yBAAyB,SAAS,OAAO,wBAAwB;AAAA,IAC1E;AAAA,EACF;AAAA,EACA,YAAY,SAAU,aAAa,QAAQ,SAAS,iBAAiB;AACnE,QAAI,kBAAkB,YAAY,uBAAuB,cAAc,gBAAgB,EAAE,OAAO,CAAC;AACjG,QAAI,MAAuC;AACzC,UAAI,CAAC,iBAAiB;AACpB,cAAM,IAAI,MAAM,iCAAiC;AAAA,MACnD;AAAA,IACF;AACA,WAAO,eAAe,CAAC,QAAQ;AAC/B,YAAQ,IAAI,UAAU,eAAe;AACrC,QAAI,WAAW,eAAe,GAAG;AAC/B,sBAAgB,IAAI,UAAU,eAAe;AAC7C,aAAO,wBAAwB;AAAA,IACjC;AAAA,EACF;AAAA,EACA,OAAO,SAAU,aAAa,QAAQ,SAAS,iBAAiB;AAC9D,QAAI,aAAa,YAAY,uBAAuB,SAAS,gBAAgB,EAAE,OAAO,CAAC;AACvF,QAAI,kBAAkB,WAAW,cAAc,YAAY;AAC3D,QAAI,iBAAiB,WAAW,cAAc,WAAW;AACzD,QAAI,MAAuC;AACzC,UAAI,CAAC,gBAAgB;AACnB,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AACA,UAAI,CAAC,iBAAiB;AACpB,cAAM,IAAI,MAAM,6BAA6B;AAAA,MAC/C;AAAA,IACF;AACA,WAAO,eAAe,CAAC,UAAU,OAAO;AACxC,YAAQ,IAAI,UAAU,eAAe;AACrC,YAAQ,IAAI,SAAS,cAAc;AACnC,QAAI,WAAW,eAAe,GAAG;AAC/B,sBAAgB,IAAI,UAAU,eAAe;AAC7C,aAAO,wBAAwB;AAAA,IACjC;AACA,QAAI,WAAW,cAAc,GAAG;AAC9B,sBAAgB,IAAI,SAAS,cAAc;AAC3C,aAAO,yBAAyB,SAAS,OAAO,wBAAwB;AAAA,IAC1E;AAAA,EACF;AAAA,EACA,KAAK,SAAU,aAAa,QAAQ,SAAS,iBAAiB;AAC5D,WAAO,eAAe,CAAC,OAAO,KAAK;AAAA,EACrC;AAAA,EACA,UAAU,SAAU,aAAa,QAAQ,SAAS,iBAAiB;AACjE,QAAI,UAAU,YAAY;AAC1B,QAAI,gBAAgB,QAAQ,aAAa,YAAY,YAAY,IAAI,eAAe,CAAC;AACrF,QAAI,eAAe,OAAO,eAAe,cAAc,WAAW,MAAM;AACxE,SAAK,cAAc,mBAAmB,SAAU,WAAW,OAAO;AAChE,UAAI,YAAY,QAAQ,aAAa,gBAAgB,SAAS;AAC9D,UAAI,UAAU,aAAa,KAAK;AAChC,cAAQ,IAAI,SAAS,SAAS;AAC9B,UAAI,WAAW,SAAS,GAAG;AACzB,wBAAgB,IAAI,SAAS,SAAS;AACtC,YAAI,OAAO,yBAAyB,MAAM;AACxC,iBAAO,wBAAwB;AAAA,QACjC;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;AACA,SAAS,WAAW,WAAW;AAC7B,SAAO,UAAU,IAAI,MAAM,MAAM;AACnC;;;ACxHA,SAAS,mBAAmB,aAAa,cAAc;AACrD,MAAI,eAAe,YAAY,IAAI,kBAAkB;AACrD,MAAI,qBAAqB,yBAAiB,IAAI,YAAY;AAC1D,MAAI;AACJ,MAAI,gBAAgB,aAAa,cAAc;AAC7C,sBAAyB,IAAI,aAAa,cAAc,SAAU,KAAK;AACrE,UAAI,UAAU;AAAA,QACZ,MAAM;AAAA,MACR;AACA,UAAI,YAAY,aAAa,QAAQ,IAAI,GAAG;AAC5C,UAAI,WAAW;AACb,YAAI,WAAW,UAAU,IAAI,MAAM;AACnC,gBAAQ,OAAO,uBAAuB,QAAQ;AAAA,MAChD;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AACA,MAAI,CAAC,iBAAiB;AAEpB,sBAAkB,uBAAuB,mBAAmB,oBAAoB,mBAAmB,kBAAkB,IAAI,mBAAmB,WAAW,MAAM,MAAM,CAAC,KAAK,GAAG;AAAA,EAC9K;AACA,SAAO;AACT;AACA,SAAS,kBAAkB,aAAa,uBAAuB,cAAc;AAC3E,MAAI;AACJ,MAAI;AACJ,kBAAuB,KAAK,aAAa,SAAU,SAAS,UAAU;AACpE,QAAI,WAAW,QAAQ;AACvB,QAAI,oBAAoB,aAAa,gBAAgB,IAAI,QAAQ;AACjE,QAAI,mBAAmB;AACrB,UAAI,yBAAyB,MAAM;AACjC,gCAAwB;AAAA,MAC1B;AACA,cAAQ,cAAc,kBAAkB,eAAe;AACvD,UAAI,uBAAuB;AACzB,gBAAQ,wBAAwB;AAAA,MAClC;AAAA,IACF;AACA,QAAI,QAAQ,UAAU,YAAY,MAAM;AACtC,sBAAgB;AAAA,IAClB;AAAA,EACF,CAAC;AACD,MAAI,CAAC,iBAAiB,yBAAyB,MAAM;AACnD,gBAAY,qBAAqB,EAAE,UAAU,WAAW;AAAA,EAC1D;AACA,SAAO;AACT;AAKA,SAAS,iBAAiB,WAAW,aAAa,KAAK;AACrD,QAAM,OAAO,CAAC;AACd,MAAI,gBAAgB,YAAY,iBAAiB;AACjD,MAAI;AACJ,MAAI,mBAAmB;AACvB,MAAI,WAAW;AACb,uBAAmB;AACnB,aAAS,iCAAiC,SAAS;AAAA,EACrD,OAAO;AACL,aAAS,cAAc,UAAU;AAEjC,uBAAmB,OAAO,iBAAiB;AAAA,EAC7C;AACA,MAAI,eAAe,wBAAwB,WAAW;AACtD,MAAI,kBAAkB,mBAAmB,aAAa,YAAY;AAClE,MAAI,qBAAqB,IAAI;AAC7B,MAAI,kBAAyB,WAAW,kBAAkB,IAAI,qBAAqB,qBAA4B,MAAM,iCAAiC,iBAAiB,WAAW,IAAI;AACtL,MAAI,yBAAyB;AAAA,IAC3B,iBAAiB;AAAA,IACjB,eAAe,IAAI;AAAA,IACnB,cAAc,YAAY,UAAU;AAAA,IACpC;AAAA,IACA,yBAAyB,CAAC;AAAA,EAC5B;AACA,MAAI,SAAS,wBAAwB,QAAQ,sBAAsB;AACnE,MAAI,wBAAwB,kBAAkB,OAAO,YAAY,IAAI,uBAAuB,YAAY;AACxG,MAAI,QAAQ,CAAC,mBAAmB,cAAc,mBAAmB,MAAM,IAAI;AAC3E,MAAI,uBAAuB,gBAAgB,aAAa;AAAA,IACtD;AAAA,IACA;AAAA,EACF,CAAC;AACD,MAAI,OAAO,IAAI,mBAAW,QAAQ,WAAW;AAC7C,OAAK,mBAAmB,oBAAoB;AAC5C,MAAI,iBAAiB,yBAAyB,QAAQ,0BAA0B,MAAM,IAAI,SAAU,SAAS,SAAS,WAAW,UAAU;AAEzI,WAAO,aAAa,wBAAwB,YAAY,KAAK,sBAAsB,SAAS,SAAS,WAAW,QAAQ;AAAA,EAC1H,IAAI;AACJ,OAAK,gBAAgB;AACrB,OAAK;AAAA;AAAA,IAEL,mBAAmB,SAAS;AAAA,IAAO;AAAA,IAAM;AAAA,EAAc;AACvD,SAAO;AACT;AACA,SAAS,0BAA0B,QAAQ;AACzC,MAAI,OAAO,iBAAiB,wBAAwB;AAClD,QAAI,aAAa,iBAAiB,OAAO,QAAQ,CAAC,CAAC;AACnD,WAAO,CAAQ,QAAQ,iBAAiB,UAAU,CAAC;AAAA,EACrD;AACF;AACA,SAAS,iBAAiB,KAAK;AAC7B,MAAI,IAAI;AACR,SAAO,IAAI,IAAI,UAAU,IAAI,CAAC,KAAK,MAAM;AACvC;AAAA,EACF;AACA,SAAO,IAAI,CAAC;AACd;AACA,IAAO,2BAAQ;",
  "names": ["DataDiffer", "map", "DimensionUserOuput", "SeriesDimensionDefine", "isObject", "map", "CtorInt32Array", "SeriesData", "resultItem", "coordDim", "resultDimIdx", "i", "map", "CoordSysInfo"]
}
