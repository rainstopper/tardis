{
  "version": 3,
  "sources": ["../../../../node_modules/echarts/lib/data/helper/SeriesDataSchema.js", "../../../../node_modules/echarts/lib/data/helper/dataStackHelper.js"],
  "sourcesContent": ["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, isObject, retrieve2 } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nimport { shouldRetrieveDataByName } from '../Source.js';\nvar inner = makeInner();\nvar dimTypeShort = {\n  float: 'f',\n  int: 'i',\n  ordinal: 'o',\n  number: 'n',\n  time: 't'\n};\n/**\n * Represents the dimension requirement of a series.\n *\n * NOTICE:\n * When there are too many dimensions in dataset and many series, only the used dimensions\n * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.\n * But users may query data by other unused dimension names.\n * In this case, users can only query data if and only if they have defined dimension names\n * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from\n * `source` dimensions.\n */\nvar SeriesDataSchema = /** @class */function () {\n  function SeriesDataSchema(opt) {\n    this.dimensions = opt.dimensions;\n    this._dimOmitted = opt.dimensionOmitted;\n    this.source = opt.source;\n    this._fullDimCount = opt.fullDimensionCount;\n    this._updateDimOmitted(opt.dimensionOmitted);\n  }\n  SeriesDataSchema.prototype.isDimensionOmitted = function () {\n    return this._dimOmitted;\n  };\n  SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {\n    this._dimOmitted = dimensionOmitted;\n    if (!dimensionOmitted) {\n      return;\n    }\n    if (!this._dimNameMap) {\n      this._dimNameMap = ensureSourceDimNameMap(this.source);\n    }\n  };\n  /**\n   * @caution Can only be used when `dimensionOmitted: true`.\n   *\n   * Get index by user defined dimension name (i.e., not internal generate name).\n   * That is, get index from `dimensionsDefine`.\n   * If no `dimensionsDefine`, or no name get, return -1.\n   */\n  SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {\n    return retrieve2(this._dimNameMap.get(dimName), -1);\n  };\n  /**\n   * @caution Can only be used when `dimensionOmitted: true`.\n   *\n   * Notice: may return `null`/`undefined` if user not specify dimension names.\n   */\n  SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {\n    var dimensionsDefine = this.source.dimensionsDefine;\n    if (dimensionsDefine) {\n      return dimensionsDefine[dimIndex];\n    }\n  };\n  SeriesDataSchema.prototype.makeStoreSchema = function () {\n    var dimCount = this._fullDimCount;\n    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);\n    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);\n    // If source don't have dimensions or series don't omit unsed dimensions.\n    // Generate from seriesDimList directly\n    var dimHash = '';\n    var dims = [];\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {\n      var property = void 0;\n      var type = void 0;\n      var ordinalMeta = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx];\n      // The list has been sorted by `storeDimIndex` asc.\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        property = willRetrieveDataByName ? seriesDimDef.name : null;\n        type = seriesDimDef.type;\n        ordinalMeta = seriesDimDef.ordinalMeta;\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n        if (sourceDimDef) {\n          property = willRetrieveDataByName ? sourceDimDef.name : null;\n          type = sourceDimDef.type;\n        }\n      }\n      dims.push({\n        property: property,\n        type: type,\n        ordinalMeta: ordinalMeta\n      });\n      // If retrieving data by index,\n      //   use <index, type, ordinalMeta> to determine whether data can be shared.\n      //   (Because in this case there might be no dimension name defined in dataset, but indices always exists).\n      //   (Indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).\n      // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),\n      //   use <property, type, ordinalMeta> in hash.\n      if (willRetrieveDataByName && property != null\n      // For data stack, we have make sure each series has its own dim on this store.\n      // So we do not add property to hash to make sure they can share this store.\n      && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {\n        dimHash += makeHashStrict\n        // Use escape character '`' in case that property name contains '$'.\n        ? property.replace(/\\`/g, '`1').replace(/\\$/g, '`2')\n        // For better performance, when there are large dimensions, tolerant this defects that hardly meet.\n        : property;\n      }\n      dimHash += '$';\n      dimHash += dimTypeShort[type] || 'f';\n      if (ordinalMeta) {\n        dimHash += ordinalMeta.uid;\n      }\n      dimHash += '$';\n    }\n    // Source from endpoint(usually series) will be read differently\n    // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.\n    // So we use this three props as key.\n    var source = this.source;\n    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$');\n    return {\n      dimensions: dims,\n      hash: hash\n    };\n  };\n  SeriesDataSchema.prototype.makeOutputDimensionNames = function () {\n    var result = [];\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {\n      var name_1 = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx];\n      // The list has been sorted by `storeDimIndex` asc.\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        if (!seriesDimDef.isCalculationCoord) {\n          name_1 = seriesDimDef.name;\n        }\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n        if (sourceDimDef) {\n          name_1 = sourceDimDef.name;\n        }\n      }\n      result.push(name_1);\n    }\n    return result;\n  };\n  SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {\n    this.dimensions.push(dimDef);\n    dimDef.isCalculationCoord = true;\n    this._fullDimCount++;\n    // If append dimension on a data store, consider the store\n    // might be shared by different series, series dimensions not\n    // really map to store dimensions.\n    this._updateDimOmitted(true);\n  };\n  return SeriesDataSchema;\n}();\nexport { SeriesDataSchema };\nexport function isSeriesDataSchema(schema) {\n  return schema instanceof SeriesDataSchema;\n}\nexport function createDimNameMap(dimsDef) {\n  var dataDimNameMap = createHashMap();\n  for (var i = 0; i < (dimsDef || []).length; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      dataDimNameMap.set(userDimName, i);\n    }\n  }\n  return dataDimNameMap;\n}\nexport function ensureSourceDimNameMap(source) {\n  var innerSource = inner(source);\n  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));\n}\nexport function shouldOmitUnusedDimensions(dimCount) {\n  return dimCount > 30;\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isString } from 'zrender/lib/core/util.js';\nimport { isSeriesDataSchema } from './SeriesDataSchema.js';\n/**\n * Note that it is too complicated to support 3d stack by value\n * (have to create two-dimension inverted index), so in 3d case\n * we just support that stacked by index.\n *\n * @param seriesModel\n * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.\n *        The input will be modified.\n * @param opt\n * @param opt.stackedCoordDimension Specify a coord dimension if needed.\n * @param opt.byIndex=false\n * @return calculationInfo\n * {\n *     stackedDimension: string\n *     stackedByDimension: string\n *     isStackedByIndex: boolean\n *     stackedOverDimension: string\n *     stackResultDimension: string\n * }\n */\nexport function enableDataStack(seriesModel, dimensionsInput, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension;\n  var dimensionDefineList;\n  var schema;\n  var store;\n  if (isLegacyDimensionsInput(dimensionsInput)) {\n    dimensionDefineList = dimensionsInput;\n  } else {\n    schema = dimensionsInput.schema;\n    dimensionDefineList = schema.dimensions;\n    store = dimensionsInput.store;\n  }\n  // Compatibal: when `stack` is set as '', do not stack.\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  each(dimensionDefineList, function (dimensionInfo, index) {\n    if (isString(dimensionInfo)) {\n      dimensionDefineList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      }\n      // Find the first stackable dimension as the stackedDimInfo.\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  }\n  // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    // Also need to use seriesModel.id as postfix because different\n    // series may share same data store. The stack dimension needs to be distinguished.\n    stackResultDimension = '__\\0ecstackresult_' + seriesModel.id;\n    stackedOverDimension = '__\\0ecstackedover_' + seriesModel.id;\n    // Create inverted index to fast query index by value.\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex_1 = 0;\n    each(dimensionDefineList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n        stackedDimCoordIndex_1++;\n      }\n    });\n    var stackedOverDimensionDefine = {\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim_1,\n      coordDimIndex: stackedDimCoordIndex_1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length\n    };\n    var stackResultDimensionDefine = {\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex_1 + 1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length + 1\n    };\n    if (schema) {\n      if (store) {\n        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);\n        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);\n      }\n      schema.appendCalculationDimension(stackedOverDimensionDefine);\n      schema.appendCalculationDimension(stackResultDimensionDefine);\n    } else {\n      dimensionDefineList.push(stackedOverDimensionDefine);\n      dimensionDefineList.push(stackResultDimensionDefine);\n    }\n  }\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\nfunction isLegacyDimensionsInput(dimensionsInput) {\n  return !isSeriesDataSchema(dimensionsInput.schema);\n}\nexport function isDimensionStacked(data, stackedDim) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n}\nexport function getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}"],
  "mappings": ";;;;;;;;;;;AA8CA,IAAI,QAAQ,UAAU;AACtB,IAAI,eAAe;AAAA,EACjB,OAAO;AAAA,EACP,KAAK;AAAA,EACL,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,MAAM;AACR;AAYA,IAAI;AAAA;AAAA,EAAgC,WAAY;AAC9C,aAASA,kBAAiB,KAAK;AAC7B,WAAK,aAAa,IAAI;AACtB,WAAK,cAAc,IAAI;AACvB,WAAK,SAAS,IAAI;AAClB,WAAK,gBAAgB,IAAI;AACzB,WAAK,kBAAkB,IAAI,gBAAgB;AAAA,IAC7C;AACA,IAAAA,kBAAiB,UAAU,qBAAqB,WAAY;AAC1D,aAAO,KAAK;AAAA,IACd;AACA,IAAAA,kBAAiB,UAAU,oBAAoB,SAAU,kBAAkB;AACzE,WAAK,cAAc;AACnB,UAAI,CAAC,kBAAkB;AACrB;AAAA,MACF;AACA,UAAI,CAAC,KAAK,aAAa;AACrB,aAAK,cAAc,uBAAuB,KAAK,MAAM;AAAA,MACvD;AAAA,IACF;AAQA,IAAAA,kBAAiB,UAAU,0BAA0B,SAAU,SAAS;AACtE,aAAO,UAAU,KAAK,YAAY,IAAI,OAAO,GAAG,EAAE;AAAA,IACpD;AAMA,IAAAA,kBAAiB,UAAU,qBAAqB,SAAU,UAAU;AAClE,UAAI,mBAAmB,KAAK,OAAO;AACnC,UAAI,kBAAkB;AACpB,eAAO,iBAAiB,QAAQ;AAAA,MAClC;AAAA,IACF;AACA,IAAAA,kBAAiB,UAAU,kBAAkB,WAAY;AACvD,UAAI,WAAW,KAAK;AACpB,UAAI,yBAAyB,yBAAyB,KAAK,MAAM;AACjE,UAAI,iBAAiB,CAAC,2BAA2B,QAAQ;AAGzD,UAAI,UAAU;AACd,UAAI,OAAO,CAAC;AACZ,eAAS,aAAa,GAAG,eAAe,GAAG,aAAa,UAAU,cAAc;AAC9E,YAAI,WAAW;AACf,YAAI,OAAO;AACX,YAAI,cAAc;AAClB,YAAI,eAAe,KAAK,WAAW,YAAY;AAE/C,YAAI,gBAAgB,aAAa,kBAAkB,YAAY;AAC7D,qBAAW,yBAAyB,aAAa,OAAO;AACxD,iBAAO,aAAa;AACpB,wBAAc,aAAa;AAC3B;AAAA,QACF,OAAO;AACL,cAAI,eAAe,KAAK,mBAAmB,UAAU;AACrD,cAAI,cAAc;AAChB,uBAAW,yBAAyB,aAAa,OAAO;AACxD,mBAAO,aAAa;AAAA,UACtB;AAAA,QACF;AACA,aAAK,KAAK;AAAA,UACR;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAOD,YAAI,0BAA0B,YAAY,SAGtC,CAAC,gBAAgB,CAAC,aAAa,qBAAqB;AACtD,qBAAW,iBAET,SAAS,QAAQ,OAAO,IAAI,EAAE,QAAQ,OAAO,IAAI,IAEjD;AAAA,QACJ;AACA,mBAAW;AACX,mBAAW,aAAa,IAAI,KAAK;AACjC,YAAI,aAAa;AACf,qBAAW,YAAY;AAAA,QACzB;AACA,mBAAW;AAAA,MACb;AAIA,UAAI,SAAS,KAAK;AAClB,UAAI,OAAO,CAAC,OAAO,gBAAgB,OAAO,YAAY,OAAO,EAAE,KAAK,IAAI;AACxE,aAAO;AAAA,QACL,YAAY;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AACA,IAAAA,kBAAiB,UAAU,2BAA2B,WAAY;AAChE,UAAI,SAAS,CAAC;AACd,eAAS,aAAa,GAAG,eAAe,GAAG,aAAa,KAAK,eAAe,cAAc;AACxF,YAAI,SAAS;AACb,YAAI,eAAe,KAAK,WAAW,YAAY;AAE/C,YAAI,gBAAgB,aAAa,kBAAkB,YAAY;AAC7D,cAAI,CAAC,aAAa,oBAAoB;AACpC,qBAAS,aAAa;AAAA,UACxB;AACA;AAAA,QACF,OAAO;AACL,cAAI,eAAe,KAAK,mBAAmB,UAAU;AACrD,cAAI,cAAc;AAChB,qBAAS,aAAa;AAAA,UACxB;AAAA,QACF;AACA,eAAO,KAAK,MAAM;AAAA,MACpB;AACA,aAAO;AAAA,IACT;AACA,IAAAA,kBAAiB,UAAU,6BAA6B,SAAU,QAAQ;AACxE,WAAK,WAAW,KAAK,MAAM;AAC3B,aAAO,qBAAqB;AAC5B,WAAK;AAIL,WAAK,kBAAkB,IAAI;AAAA,IAC7B;AACA,WAAOA;AAAA,EACT,EAAE;AAAA;AAEK,SAAS,mBAAmB,QAAQ;AACzC,SAAO,kBAAkB;AAC3B;AACO,SAAS,iBAAiB,SAAS;AACxC,MAAI,iBAAiB,cAAc;AACnC,WAAS,IAAI,GAAG,KAAK,WAAW,CAAC,GAAG,QAAQ,KAAK;AAC/C,QAAI,gBAAgB,QAAQ,CAAC;AAC7B,QAAI,cAAc,SAAS,aAAa,IAAI,cAAc,OAAO;AACjE,QAAI,eAAe,QAAQ,eAAe,IAAI,WAAW,KAAK,MAAM;AAClE,qBAAe,IAAI,aAAa,CAAC;AAAA,IACnC;AAAA,EACF;AACA,SAAO;AACT;AACO,SAAS,uBAAuB,QAAQ;AAC7C,MAAI,cAAc,MAAM,MAAM;AAC9B,SAAO,YAAY,eAAe,YAAY,aAAa,iBAAiB,OAAO,gBAAgB;AACrG;AACO,SAAS,2BAA2B,UAAU;AACnD,SAAO,WAAW;AACpB;;;AC9JO,SAAS,gBAAgB,aAAa,iBAAiB,KAAK;AACjE,QAAM,OAAO,CAAC;AACd,MAAI,UAAU,IAAI;AAClB,MAAI,wBAAwB,IAAI;AAChC,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,wBAAwB,eAAe,GAAG;AAC5C,0BAAsB;AAAA,EACxB,OAAO;AACL,aAAS,gBAAgB;AACzB,0BAAsB,OAAO;AAC7B,YAAQ,gBAAgB;AAAA,EAC1B;AAEA,MAAI,WAAW,CAAC,EAAE,eAAe,YAAY,IAAI,OAAO;AACxD,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,OAAK,qBAAqB,SAAU,eAAe,OAAO;AACxD,QAAI,SAAS,aAAa,GAAG;AAC3B,0BAAoB,KAAK,IAAI,gBAAgB;AAAA,QAC3C,MAAM;AAAA,MACR;AAAA,IACF;AACA,QAAI,YAAY,CAAC,cAAc,cAAc;AAE3C,UAAI,CAAC,WAAW,CAAC,oBAAoB,cAAc,aAAa;AAC9D,2BAAmB;AAAA,MACrB;AAEA,UAAI,CAAC,kBAAkB,cAAc,SAAS,aAAa,cAAc,SAAS,WAAW,CAAC,yBAAyB,0BAA0B,cAAc,WAAW;AACxK,yBAAiB;AAAA,MACnB;AAAA,IACF;AAAA,EACF,CAAC;AACD,MAAI,kBAAkB,CAAC,WAAW,CAAC,kBAAkB;AAGnD,cAAU;AAAA,EACZ;AAIA,MAAI,gBAAgB;AAIlB,2BAAuB,uBAAuB,YAAY;AAC1D,2BAAuB,uBAAuB,YAAY;AAE1D,QAAI,kBAAkB;AACpB,uBAAiB,wBAAwB;AAAA,IAC3C;AACA,QAAI,uBAAuB,eAAe;AAC1C,QAAI,iBAAiB,eAAe;AACpC,QAAI,yBAAyB;AAC7B,SAAK,qBAAqB,SAAU,eAAe;AACjD,UAAI,cAAc,aAAa,sBAAsB;AACnD;AAAA,MACF;AAAA,IACF,CAAC;AACD,QAAI,6BAA6B;AAAA,MAC/B,MAAM;AAAA,MACN,UAAU;AAAA,MACV,eAAe;AAAA,MACf,MAAM;AAAA,MACN,cAAc;AAAA,MACd,oBAAoB;AAAA,MACpB,eAAe,oBAAoB;AAAA,IACrC;AACA,QAAI,6BAA6B;AAAA,MAC/B,MAAM;AAAA;AAAA;AAAA,MAGN,UAAU;AAAA,MACV,eAAe,yBAAyB;AAAA,MACxC,MAAM;AAAA,MACN,cAAc;AAAA,MACd,oBAAoB;AAAA,MACpB,eAAe,oBAAoB,SAAS;AAAA,IAC9C;AACA,QAAI,QAAQ;AACV,UAAI,OAAO;AACT,mCAA2B,gBAAgB,MAAM,2BAA2B,sBAAsB,cAAc;AAChH,mCAA2B,gBAAgB,MAAM,2BAA2B,sBAAsB,cAAc;AAAA,MAClH;AACA,aAAO,2BAA2B,0BAA0B;AAC5D,aAAO,2BAA2B,0BAA0B;AAAA,IAC9D,OAAO;AACL,0BAAoB,KAAK,0BAA0B;AACnD,0BAAoB,KAAK,0BAA0B;AAAA,IACrD;AAAA,EACF;AACA,SAAO;AAAA,IACL,kBAAkB,kBAAkB,eAAe;AAAA,IACnD,oBAAoB,oBAAoB,iBAAiB;AAAA,IACzD,kBAAkB;AAAA,IAClB;AAAA,IACA;AAAA,EACF;AACF;AACA,SAAS,wBAAwB,iBAAiB;AAChD,SAAO,CAAC,mBAAmB,gBAAgB,MAAM;AACnD;AACO,SAAS,mBAAmB,MAAM,YAAY;AAGnD,SAAO,CAAC,CAAC,cAAc,eAAe,KAAK,mBAAmB,kBAAkB;AAClF;AACO,SAAS,oBAAoB,MAAM,WAAW;AACnD,SAAO,mBAAmB,MAAM,SAAS,IAAI,KAAK,mBAAmB,sBAAsB,IAAI;AACjG;",
  "names": ["SeriesDataSchema"]
}
